{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RBACX","text":"<p>RBAC + ABAC + ReBAC authorization for Python with a clean architecture, declarative JSON policies, framework adapters, and optional hot reloading.</p>"},{"location":"#inspiration-philosophy","title":"Inspiration &amp; Philosophy","text":"<p>RBACX is inspired by: - OWASP-aligned practices like deny by default and least privilege. - The recurring pain for Python developers switching between projects with inconsistent authorization stacks. - The XACML model (policies, rules, effects, combining algorithms, obligations), simplified and made friendlier for web developers using JSON and a Python-first API.</p> <p>Our philosophy: security should be understandable and ergonomic for developers so that correct authorization becomes the path of least resistance.</p>"},{"location":"#what-you-get","title":"What you get","text":"<ul> <li>RBAC + ABAC + ReBAC in a single engine (role checks, attribute conditions, and relationship checks).</li> <li>Declarative policies (JSON/YAML or Python dict) with compact operators, including time operators and <code>rel</code> condition for relationship checks.</li> <li>Secure defaults: <code>deny-overrides</code> by default; also <code>permit-overrides</code>, <code>first-applicable</code>.</li> <li>Role hierarchy via resolvers (<code>StaticRoleResolver</code> and custom implementations).</li> <li>Explainable decisions (<code>allowed</code>, <code>effect</code>, <code>reason</code>, <code>rule_id</code>) and obligations (e.g., require MFA).</li> <li>ReBAC providers: optional integrations for OpenFGA and SpiceDB/Authzed.</li> <li>Hot reload from file/HTTP/S3 using ETag checks.</li> <li>Adapters for FastAPI/Starlette, Flask, Django/DRF, Litestar.</li> <li>Observability: logging hooks and metrics sinks (Prometheus/OpenTelemetry).</li> <li>Optional decision caching: pluggable cache (<code>AbstractCache</code>) per <code>Guard</code>, with in-memory LRU+TTL default. Enable via <code>cache</code> / <code>cache_ttl</code>; clear with <code>guard.clear_cache()</code>.</li> <li>CLI &amp; linting: <code>rbacx validate</code> to schema\u2011check, <code>rbacx lint</code> to lint, <code>rbacx check</code> to validate then lint.</li> <li>Test coverage around 100% across core decision paths.</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#1-install","title":"1) Install","text":"<pre><code>pip install rbacx\n</code></pre>"},{"location":"#2-define-a-minimal-policy-json","title":"2) Define a minimal policy (JSON)","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"allow_read_public\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ { \"attr\": \"resource.visibility\" }, \"public\" ] },\n      \"obligations\": [ { \"type\": \"require_mfa\", \"on\": \"permit\" } ]\n    }\n  ]\n}\n</code></pre>"},{"location":"#3-evaluate-in-python","title":"3) Evaluate in Python","text":"<pre><code>from rbacx import Guard\n\npolicy = {...}  # load JSON as a dict\ng = Guard(policy)\n\ndecision = g.evaluate_sync(\n    subject={\"id\": \"u1\", \"roles\": [\"reader\"]},\n    action=\"read\",\n    resource={\"type\": \"document\", \"visibility\": \"public\"},\n    context={\"mfa\": True},\n)\n\nassert decision.allowed is True\nprint(decision.effect, decision.reason, decision.rule_id, decision.obligations)\n</code></pre>"},{"location":"#4-optional-use-a-web-adapter","title":"4) (Optional) Use a web adapter","text":"<p>FastAPI <pre><code>from fastapi import FastAPI, Request\nfrom rbacx import Action, Context, Guard, Resource, Subject\nfrom rbacx.adapters.fastapi import require_access\n\napp = FastAPI()\n\npolicy = {...}  # reuse the policy from above or define one here\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    user = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\n\n@app.get(\"/docs\")\n@require_access(guard, build_env)\ndef docs():\n    return {\"ok\": True}\n</code></pre></p>"},{"location":"#documentation-map","title":"Documentation map","text":"<p>Start here - Quickstart - Why choose RBACX - Highlights - Strategies</p> <p>Core concepts - Architecture - Security model - Explainability (reasons &amp; obligations) - Role hierarchy - Audit mode - Obligations - Decision caching - Types</p> <p>Policy - Policy authoring - Policy catalog - Time operators - Policy loading (hot reload) - Policy stores - Custom Policy Source - HTTP mapping</p> <p>ReBAC - Overview - Local Provider - OpenFGA Provider - SpiceDB / Authzed Provider</p> <p>Integration - Web adapters - Custom adapters - Try examples</p> <p>Observability - Metrics - OpenTelemetry - Prometheus - Logging - Policy diagnostics - Observability stack</p> <p>Performance &amp; operations - Performance guide - Benchmarks - CI - Migration (RBAC\u2192ABAC)</p> <p>Reference - Public API</p>"},{"location":"adapters/","title":"Adapters \u2014 build your own in 3 steps","text":"<p>Adapters are thin wrappers around the RBACX <code>Guard</code>. They map a framework event/request to a decision and translate that decision into the framework\u2019s native outcome. Because the core is framework-independent, you can integrate it into web apps, GUIs, CLIs, services \u2014 anywhere.</p> <p>Terminology (S/A/R/C)</p> <ul> <li>Subject \u2014 who acts (user id, roles, attributes)</li> <li>Action \u2014 what operation is requested (string key, e.g. <code>\"document.update\"</code>)</li> <li>Resource \u2014 what it targets (domain object type/id/attributes)</li> <li>Context \u2014 extra facts (tenant, flags, mode, time, environment, etc.)</li> </ul>"},{"location":"adapters/#what-you-need-before-you-start","title":"What you need before you start","text":"<ul> <li>A place to read who acts (auth/session), what is requested (command/router), what it targets (current domain entity), and context (tenant/flags/mode/time/etc.).</li> <li>A <code>Guard</code> instance available where you handle requests/commands.</li> <li>A native way to express deny in your environment (return code/exception/HTTP 403/etc.).</li> </ul> <p>Guard initialization (policy, logging, metrics, roles, obligations)</p> <pre><code>from rbacx import Guard\n\nguard = Guard(\n    policy=...,                  # required: policy or policy set (as a dict)\n    logger_sink=...,             # optional: object with .log(payload) -&gt; None/awaitable\n    metrics=...,                 # optional: object with .inc(name, labels) and/or .observe(name, value, labels)\n    obligation_checker=...,      # optional: validates obligations (defaults to BasicObligationChecker)\n    role_resolver=...,           # optional: expands roles (may be sync or async)\n    cache=...,                   # optional: decision cache implementation (AbstractCache)\n    cache_ttl=...,               # optional: time-to-live for cached entries (seconds)\n    strict_types=...,            # optional: strict typing (default False); exact matches + aware datetimes when True\n)\n</code></pre> <p>Notes:</p> <ul> <li><code>Guard</code> has a single async core; <code>evaluate_sync</code> wraps it safely (runs directly if no loop is active, or uses a helper thread if a loop is already running).</li> </ul>"},{"location":"adapters/#choose-sync-vs-async","title":"Choose sync vs async","text":"<ul> <li>Use <code>guard.evaluate_sync(...)</code> in synchronous handlers.</li> <li>Use <code>await guard.evaluate_async(...)</code> when your app runs an event loop (evented GUIs, async servers).</li> </ul> <p>Rule of thumb: if your handler is already <code>async</code> or runs on an event loop, use the async call; otherwise use the sync call.</p>"},{"location":"adapters/#the-3-steps-to-implement-your-adapter","title":"The 3 steps to implement your adapter","text":"<ol> <li>Build the environment \u2014 convert your event/request to <code>(Subject, Action, Resource, Context)</code> with an <code>EnvBuilder</code>.</li> <li>Evaluate \u2014 call the appropriate <code>Guard</code> method (sync or async).</li> <li>Translate the result \u2014 on permit continue; on deny return the native \u201cforbidden\u201d outcome for your framework.</li> </ol>"},{"location":"adapters/#walkthrough-gui-example","title":"Walkthrough (GUI example)","text":"<p>This example shows a realistic desktop wiring: commands arrive via your controller, the current target comes from a selection model, and app-level facts come from a context snapshot. The same 1\u20132\u20133 applies to web or any other stack.</p>"},{"location":"adapters/#1-build-the-environment-sarc","title":"1) Build the environment (S/A/R/C)","text":"<pre><code>from typing import Any, Tuple\nfrom rbacx import Subject, Action, Resource, Context\n\nclass AuthService:        # who acts\n    @property\n    def current_user(self): ...  # -&gt; object with .id, .roles, .attrs\n\nclass CommandRegistry:    # what operation\n    def to_action_name(self, command_id: str) -&gt; str: ...\n\nclass SelectionBridge:    # what it targets (current domain entity)\n    def current_resource(self) -&gt; tuple[str, str, dict]:\n        # e.g., (\"document\", \"DOC-123\", {\"owner\": \"u17\"})\n        ...\n\nclass AppContext:         # extra facts\n    def snapshot(self) -&gt; dict: ...\n\nclass RbacEnv:\n    def __init__(self, auth: AuthService, commands: CommandRegistry,\n                 selection: SelectionBridge, appctx: AppContext):\n        self.auth, self.commands, self.selection, self.appctx = auth, commands, selection, appctx\n\n    def build_env(self, raw_event: Any) -&gt; Tuple[Subject, Action, Resource, Context]:\n        # Subject\n        u = self.auth.current_user\n        subject = Subject(id=u.id, roles=list(u.roles), attrs=dict(u.attrs or {}))\n\n        # Action\n        command_id = getattr(raw_event, \"command_id\", None) or str(raw_event)\n        action = Action(name=self.commands.to_action_name(command_id))\n\n        # Resource\n        r_type, r_id, r_attrs = self.selection.current_resource()\n        resource = Resource(type=r_type, id=r_id, attrs=r_attrs)\n\n        # Context\n        context = Context(attrs=self.appctx.snapshot())\n\n        # Edge cases (no selection / no command)\n        if r_type is None or r_id is None:\n            resource = Resource(type=\"*\", id=None, attrs={})\n        if not action.name:\n            action = Action(name=\"unknown\")\n\n        return subject, action, resource, context\n</code></pre>"},{"location":"adapters/#2-evaluate","title":"2) Evaluate","text":"<pre><code>env = RbacEnv(auth, commands, selection, appctx)\n\ndef handle_command(event):\n    s, a, r, c = env.build_env(event)\n    return guard.evaluate_sync(s, a, r, c)\n\n# async variant (if your GUI runs an event loop integrated with asyncio)\nasync def handle_command_async(event):\n    s, a, r, c = env.build_env(event)\n    return await guard.evaluate_async(s, a, r, c)\n</code></pre>"},{"location":"adapters/#3-translate-the-result","title":"3) Translate the result","text":"<pre><code>def apply_decision(decision):\n    if decision.allowed:\n        return {\"ok\": True}\n    # keep diagnostics off by default; enable explicitly if needed\n    return {\"ok\": False, \"error\": \"Forbidden\"}\n</code></pre>"},{"location":"adapters/#end-to-end-snippet-copy-paste","title":"End-to-end snippet (copy &amp; paste)","text":"<pre><code># 1) build\ns, a, r, c = env.build_env(event)\n# 2) evaluate\ndecision = guard.evaluate_sync(s, a, r, c)\n# 3) translate\nresult = {\"ok\": True} if decision.allowed else {\"ok\": False, \"error\": \"Forbidden\"}\n</code></pre>"},{"location":"adapters/#decision-shape-what-you-can-use","title":"Decision shape (what you can use)","text":"<p><code>Decision</code> exposes: <code>allowed</code>, <code>effect</code>, <code>reason</code>, <code>rule_id</code>, <code>policy_id</code>, <code>obligations</code>, <code>challenge</code>. Keep reasons/ids disabled by default; surface them only in explicit diagnostic/audit modes.</p>"},{"location":"adapters/#practical-tips","title":"Practical tips","text":"<ul> <li>Centralize S/A/R/C. Keep one <code>EnvBuilder</code> responsible for turning events into <code>(Subject, Action, Resource, Context)</code>.</li> <li>Match your runtime. Choose sync or async once and keep handlers consistent.</li> <li>Safe by default. Don\u2019t surface <code>reason</code>/<code>rule_id</code>/<code>policy_id</code> unless explicitly enabled.</li> <li>Guard construction. Start minimal (<code>policy</code> only); add <code>logger_sink</code>, <code>metrics</code>, <code>role_resolver</code>, or a custom <code>obligation_checker</code> as your application needs grow.</li> </ul>"},{"location":"adapters/#takeaways","title":"Takeaways","text":"<ul> <li>Adapters are thin wrappers: build \u2192 evaluate \u2192 translate.</li> <li>The engine is platform-neutral: the same contract works for GUI, web, CLI, and services.</li> <li>With a clear <code>EnvBuilder</code> and the right sync/async call, integrating RBACX is straightforward.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#rbacx.core.engine.Guard","title":"<code>Guard(policy, *, logger_sink=None, metrics=None, obligation_checker=None, role_resolver=None, relationship_checker=None, cache=None, cache_ttl=300, strict_types=False)</code>","text":"<p>Policy evaluation engine.</p> <p>Holds a policy or a policy set and evaluates access decisions.</p> Design <ul> <li>Single async core <code>_evaluate_core_async</code> (one source of truth).</li> <li>Sync API wraps the async core; if a loop is already running, uses a helper thread.</li> <li>DI (resolver/obligations/metrics/logger) can be sync or async; both supported via <code>maybe_await</code>.</li> <li>CPU-bound evaluation is offloaded to a thread via <code>asyncio.to_thread</code>.</li> <li>On init we ensure a current event loop exists in this thread so   legacy tests using <code>asyncio.get_event_loop().run_until_complete(...)</code>   don\u2019t crash on Python 3.12+.</li> </ul>"},{"location":"api/#rbacx.core.engine.Guard.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the decision cache if configured.</p> <p>This is safe to call at any time. Errors are swallowed to avoid interfering with decision flow.</p>"},{"location":"api/#rbacx.core.engine.Guard.evaluate_async","title":"<code>evaluate_async(subject, action, resource, context=None)</code>  <code>async</code>","text":"<p>True async API for ASGI frameworks.</p>"},{"location":"api/#rbacx.core.engine.Guard.evaluate_sync","title":"<code>evaluate_sync(subject, action, resource, context=None)</code>","text":"<p>Synchronous wrapper for the async core. - If no running loop in this thread: use asyncio.run(...) - If a loop is running: run the async core in a helper thread with its own loop.</p>"},{"location":"api/#rbacx.core.engine.Guard.set_policy","title":"<code>set_policy(policy)</code>","text":"<p>Replace policy/policyset.</p>"},{"location":"api/#rbacx.core.engine.Guard.update_policy","title":"<code>update_policy(policy)</code>","text":"<p>Alias kept for backward-compatibility.</p>"},{"location":"api/#rbacx.core.policy.ConditionTypeError","title":"<code>ConditionTypeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a condition compares incompatible types.</p>"},{"location":"api/#rbacx.core.policy.eval_condition","title":"<code>eval_condition(cond, env)</code>","text":"<p>Evaluate condition dict safely. On type mismatches, raise ConditionTypeError.</p>"},{"location":"api/#rbacx.core.policy.resolve","title":"<code>resolve(token, env)</code>","text":"<p>Resolve a token; supports {\"attr\": \"a.b.c\"} lookups in env.</p>"},{"location":"api/#rbacx.core.policyset.decide","title":"<code>decide(policyset, env)</code>","text":"<p>Evaluate a policy set with combining algorithm over its child policies.</p>"},{"location":"api/#rbacx.core.ports.RoleResolver","title":"<code>RoleResolver</code>","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/#rbacx.core.ports.RoleResolver.expand","title":"<code>expand(roles)</code>","text":"<p>Return roles including inherited/derived ones.</p>"},{"location":"api/#rbacx.logging.decision_logger.DecisionLogger","title":"<code>DecisionLogger(*, sample_rate=1.0, redactions=None, logger_name='rbacx.audit', as_json=False, level=logging.INFO, redact_in_place=False, use_default_redactions=False, smart_sampling=False, category_sampling_rates=None, max_env_bytes=None)</code>","text":"<p>               Bases: <code>DecisionLogSink</code></p> <p>Minimal, framework-agnostic audit logger for PDP decisions.</p> Backwards-compatible defaults <ul> <li>No redactions are applied unless explicitly configured.</li> <li><code>sample_rate</code> controls probabilistic logging: 0.0 \u2192 drop all, 1.0 \u2192 log all.</li> <li>Smart sampling is disabled by default.</li> <li>No env size limit by default.</li> </ul> Opt-in features <ul> <li><code>use_default_redactions=True</code> enables DEFAULT_REDACTIONS when <code>redactions</code> is not provided.</li> <li><code>smart_sampling=True</code> enables category-aware sampling (deny and permit-with-obligations can be forced to 1.0).</li> <li><code>max_env_bytes</code> truncates the (redacted) env if the serialized JSON exceeds the threshold.</li> </ul>"},{"location":"api/#rbacx.core.obligations.BasicObligationChecker","title":"<code>BasicObligationChecker</code>","text":"<p>               Bases: <code>ObligationChecker</code></p> <p>Validate common obligations carried by a decision.</p> <p>Design goals (documented for contributors): - Fail-closed semantics preserved for legacy callers:   * If legacy string key <code>decision</code> is present and not equal to \"permit\" -&gt; <code>(False, None)</code>.   * If legacy key absent, derive effect from <code>effect</code>/<code>allowed</code>; any non-\"permit\" -&gt; <code>(False, None)</code>. - Support obligations targeting the current effect (<code>on: \"permit\" | \"deny\"</code>).   This allows, for example, an explicit <code>http_challenge</code> on <code>deny</code> to still surface a challenge. - Do not mutate the incoming decision; return a <code>(ok, challenge)</code> tuple for the Guard to consume. - Unknown obligation <code>type</code> is ignored (treated as advice/no-op).</p> <p>Supported <code>type</code> values:   - <code>require_mfa</code>            -&gt; challenge \"mfa\"   - <code>require_level</code>          (attrs.min)  -&gt; \"step_up\"   - <code>http_challenge</code>         (attrs.scheme in Basic/Bearer/Digest) -&gt; \"http_basic\" / \"http_bearer\" / \"http_digest\"; else \"http_auth\"   - <code>require_consent</code>        (attrs.key or any consent) -&gt; \"consent\"   - <code>require_terms_accept</code>   -&gt; \"tos\"   - <code>require_captcha</code>        -&gt; \"captcha\"   - <code>require_reauth</code>         (attrs.max_age vs context.reauth_age_seconds) -&gt; \"reauth\"   - <code>require_age_verified</code>   -&gt; \"age_verification\"</p>"},{"location":"api/#rbacx.core.obligations.BasicObligationChecker.check","title":"<code>check(decision, context)</code>","text":"<p>Check obligations attached to a raw decision.</p>"},{"location":"api/#rbacx.core.obligations.BasicObligationChecker.check--parameters","title":"Parameters","text":"<p>decision: Mapping-like (dict). Legacy callers may pass string key <code>decision</code> (\"permit\"|\"deny\");           modern shape may include <code>effect</code>/<code>allowed</code>. <code>obligations</code> is a list of mappings. context : Object whose <code>.attrs</code> is a dict (or context itself is a dict).</p>"},{"location":"api/#rbacx.core.obligations.BasicObligationChecker.check--returns","title":"Returns","text":"<p>(ok, challenge): bool and optional machine-readable challenge string.</p>"},{"location":"api/#rbacx.core.obligations.ObligationCheckResult","title":"<code>ObligationCheckResult(ok, challenge=None, reason=None)</code>  <code>dataclass</code>","text":"<p>Small DTO kept for backwards-compatibility if needed by contributors.</p>"},{"location":"api/#rbacx.core.cache.AbstractCache","title":"<code>AbstractCache</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal cache interface for dependency inversion.</p> <p>Implementations MUST be safe to call from multiple threads in-process or be clearly documented otherwise.</p> <p>get should return None if a key doesn't exist or is expired. set may accept an optional TTL in seconds.</p>"},{"location":"api/#rbacx.core.cache.DefaultInMemoryCache","title":"<code>DefaultInMemoryCache(maxsize=2048)</code>","text":"<p>               Bases: <code>AbstractCache</code></p> <p>Thread-safe in-memory LRU cache with optional per-key TTL.</p>"},{"location":"api/#rbacx.core.cache.DefaultInMemoryCache--notes","title":"Notes","text":"<ul> <li>Uses time.monotonic() for TTL to avoid wall clock changes.</li> <li>Designed for single process scenarios. For multi-process/multi-host,   inject a distributed cache implementation that conforms to AbstractCache.</li> <li>Values are stored as-is; callers are responsible for storing immutable   or copy-safe data if necessary.</li> </ul>"},{"location":"api/#rbacx.core.roles.StaticRoleResolver","title":"<code>StaticRoleResolver(graph=None)</code>","text":"<p>               Bases: <code>RoleResolver</code></p> <p>Simple in-memory role resolver with inheritance.</p> <p>graph: {role: [parent_role, ...]} expand(['manager']) -&gt; ['manager', 'employee', 'user', ...]</p>"},{"location":"api/#rbacx.policy.HotReloader","title":"<code>HotReloader(guard, source, *, initial_load=False, poll_interval=5.0, backoff_min=2.0, backoff_max=30.0, jitter_ratio=0.15, thread_daemon=True)</code>","text":"<p>Unified, production-grade policy reloader.</p> Features <ul> <li>ETag-first logic: call source.etag() and only load/apply when it changes.</li> <li>Error suppression with exponential backoff + jitter to avoid log/IO storms.</li> <li>Optional background polling loop with clean start/stop.</li> <li>Backwards-compatible one-shot API aliases: refresh_if_needed()/poll_once().</li> </ul> Notes <ul> <li>If source.etag() returns None, we will attempt to load() and let the source decide.</li> <li>Guard.set_policy(policy) is called only after a successful load().</li> <li>This class is thread-safe for concurrent check_and_reload() calls.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial_load</code> <code>bool</code> <p>Controls startup behavior.   - False (default): prime ETag at construction time; the first check will NO-OP     unless the policy changes. (Backwards-compatible with previous versions.)   - True: do not prime ETag; the first check will load the current policy.</p> <code>False</code>"},{"location":"api/#rbacx.policy.HotReloader.check_and_reload","title":"<code>check_and_reload(*, force=False)</code>","text":"<p>Perform a single reload check (sync wrapper over the async core).</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>If True, load/apply the policy regardless of ETag state.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if a new policy was loaded and applied; otherwise False.</p>"},{"location":"api/#rbacx.policy.HotReloader.check_and_reload_async","title":"<code>check_and_reload_async(*, force=False)</code>  <code>async</code>","text":"Async-aware reload check <ul> <li>supports sync/async PolicySource.etag()/load() via _maybe_await</li> <li>never holds the thread lock while awaiting</li> </ul>"},{"location":"api/#rbacx.policy.HotReloader.start","title":"<code>start(interval=None, *, initial_load=None, force_initial=False)</code>","text":"<p>Start the background polling thread.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float | None</code> <p>seconds between checks; if None, uses self.poll_interval (or 5.0 fallback).</p> <code>None</code> <code>initial_load</code> <code>bool | None</code> <p>override constructor's initial_load just for this start().           If True, perform a synchronous load/check before starting the thread.           If False, skip any initial load.           If None, inherit the constructor setting.</p> <code>None</code> <code>force_initial</code> <code>bool</code> <p>if True and an initial load is requested, bypass the ETag check            for that initial load (equivalent to check_and_reload(force=True)).</p> <code>False</code>"},{"location":"api/#rbacx.policy.HotReloader.stop","title":"<code>stop(timeout=1.0)</code>","text":"<p>Signal the polling thread to stop and optionally wait for it.</p>"},{"location":"api/#rbacx.rebac.ComputedUserset","title":"<code>ComputedUserset(relation)</code>  <code>dataclass</code>","text":"<p>Follow another relation on the SAME object.</p>"},{"location":"api/#rbacx.rebac.InMemoryRelationshipStore","title":"<code>InMemoryRelationshipStore()</code>","text":"<p>Minimal tuple store with indexes by (resource, relation) and (subject, relation). Suitable for tests/dev. For production, implement the same interface on top of a DB.</p>"},{"location":"api/#rbacx.rebac.LocalRelationshipChecker","title":"<code>LocalRelationshipChecker(store, *, rules=None, caveat_registry=None, max_depth=8, max_nodes=10000, deadline_ms=50)</code>","text":"<p>               Bases: <code>RelationshipChecker</code></p> In-process ReBAC implementation based on a userset-rewrite graph <ul> <li>primitives: union (list), This, ComputedUserset, TupleToUserset</li> <li>safety limits: max_depth, max_nodes, deadline_ms</li> <li>conditional tuples via a caveat registry (predicate by name)</li> </ul>"},{"location":"api/#rbacx.rebac.This","title":"<code>This()</code>  <code>dataclass</code>","text":"<p>Direct relation: subject --relation--&gt; resource (aka 'this').</p>"},{"location":"api/#rbacx.rebac.TupleToUserset","title":"<code>TupleToUserset(tupleset, computed_userset)</code>  <code>dataclass</code>","text":"<p>Traverse an object-&gt;object edge first (tupleset) and then evaluate a relation ('computed_userset') on the TARGET object.</p>"},{"location":"api/#rbacx.rebac.openfga.OpenFGAChecker","title":"<code>OpenFGAChecker(config, *, client=None, async_client=None)</code>","text":"<p>               Bases: <code>RelationshipChecker</code></p> <p>ReBAC provider backed by OpenFGA HTTP API.</p> <ul> <li>Uses /stores/{store_id}/check and /stores/{store_id}/batch-check.</li> <li>For conditions, forwards <code>context</code> (OpenFGA merges persisted and request contexts).</li> <li>If both clients are provided, AsyncClient takes precedence (methods return awaitables).</li> </ul>"},{"location":"api/#rbacx.rebac.openfga.OpenFGAConfig","title":"<code>OpenFGAConfig(api_url, store_id, authorization_model_id=None, api_token=None, timeout_seconds=2.0)</code>  <code>dataclass</code>","text":"<p>Minimal configuration for OpenFGA HTTP client.</p>"},{"location":"api/#rbacx.rebac.spicedb.SpiceDBChecker","title":"<code>SpiceDBChecker(config, *, async_mode=False)</code>","text":"<p>               Bases: <code>RelationshipChecker</code></p> <p>ReBAC provider backed by the SpiceDB/Authzed gRPC API.</p> <ul> <li>Uses CheckPermission; batch -&gt; sequential calls (gRPC has no one-shot batch).</li> <li>Consistency: ZedToken (at_least_as_fresh) or fully_consistent.</li> <li>Caveats: pass context as google.protobuf.Struct.</li> </ul>"},{"location":"api/#rbacx.rebac.spicedb.SpiceDBConfig","title":"<code>SpiceDBConfig(endpoint, token=None, insecure=False, prefer_fully_consistent=False, timeout_seconds=2.0)</code>  <code>dataclass</code>","text":"<p>Minimal configuration for the SpiceDB/Authzed gRPC client.</p>"},{"location":"api/#rbacx.store.file_store.FilePolicySource","title":"<code>FilePolicySource(path, *, validate_schema=False, include_mtime_in_etag=False, chunk_size=512 * 1024)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by a local JSON file.</p> ETag semantics <ul> <li>By default, ETag = SHA-256 of file content.</li> <li>If include_mtime_in_etag=True, the ETag also includes mtime (ns),   so a simple \"touch\" (metadata-only change) will trigger a reload.</li> </ul> <p>The class caches the last SHA by (size, mtime_ns) to avoid unnecessary hashing.</p>"},{"location":"api/#rbacx.store.file_store.atomic_write","title":"<code>atomic_write(path, data, *, encoding='utf-8')</code>","text":"<p>Write data atomically to path using a temp file + os.replace().</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource","title":"<code>S3PolicySource(url, *, client=None, session=None, config=None, client_extra=None, validate_schema=True, change_detector='etag', prefer_checksum='sha256')</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by Amazon S3.</p> <p>Change detection strategies (choose one via <code>change_detector</code>):   - \"etag\"        : HeadObject ETag (default).   - \"version_id\"  : HeadObject VersionId (requires bucket versioning).   - \"checksum\"    : GetObjectAttributes(..., ObjectAttributes=['Checksum']) if available.</p> <p>Networking defaults are production-friendly (timeouts + retries) and can be overridden via a custom botocore Config or client parameters.</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource.etag","title":"<code>etag()</code>","text":"<p>Return the current change marker according to <code>change_detector</code>.</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource.load","title":"<code>load()</code>","text":"<p>Download and parse the policy document from S3.</p> <p>The format (JSON vs YAML) is auto-detected using the object key (filename) and/or content.</p>"},{"location":"api/#rbacx.store.http_store.HTTPPolicySource","title":"<code>HTTPPolicySource(url, *, headers=None, validate_schema=False)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>HTTP policy source using <code>requests</code> with ETag support. Extra: rbacx[http]</p>"},{"location":"api/#rbacx.adapters.asgi.RbacxMiddleware","title":"<code>RbacxMiddleware(app, *, guard, mode='enforce', build_env=None, add_headers=False)</code>","text":"<p>Framework-agnostic ASGI middleware.</p> Modes <ul> <li>\"inject\": only injects guard into scope.</li> <li>\"enforce\": evaluates access for HTTP requests when build_env is provided.</li> </ul> Security <ul> <li>Does not leak denial reasons in the response body.</li> <li>If <code>add_headers=True</code>, attaches <code>X-RBACX-*</code> headers on deny.</li> </ul>"},{"location":"api/#rbacx.adapters.flask.require_access","title":"<code>require_access(guard, build_env, *, add_headers=False)</code>","text":"<p>Decorator for Flask view functions to enforce access.</p>"},{"location":"api/#rbacx.adapters.django.middleware.RbacxDjangoMiddleware","title":"<code>RbacxDjangoMiddleware(get_response)</code>","text":"<p>Inject a Guard instance onto each Django request as <code>request.rbacx_guard</code>.</p> Config <ul> <li>settings.RBACX_GUARD_FACTORY: dotted path to a zero-arg callable returning a Guard.</li> </ul> Notes <ul> <li>Middleware init(get_response) runs once at startup; guard is created once.</li> <li>call(request) runs per-request; we attach the same guard to each request.</li> </ul>"},{"location":"api/#rbacx.adapters.litestar.RBACXMiddleware","title":"<code>RBACXMiddleware(app, *, guard, build_env, add_headers=False)</code>","text":"<p>               Bases: <code>AbstractMiddleware</code></p> <p>Litestar middleware that checks access using RBACX Guard.</p> <ul> <li>Prefers :class:<code>litestar.middleware.ASGIMiddleware</code> (Litestar &gt;= 2.15).</li> <li>Falls back to :class:<code>litestar.middleware.AbstractMiddleware</code> when needed.</li> <li>Uses :py:meth:<code>Guard.evaluate_async</code>.</li> </ul>"},{"location":"api/#decision-object","title":"Decision object","text":"<p>Fields returned by <code>Guard.evaluate*</code>:</p> <ul> <li><code>allowed: bool</code></li> <li><code>effect: \"permit\" | \"deny\"</code></li> <li><code>obligations: List[Dict[str, Any]]</code></li> <li><code>challenge: Optional[str]</code></li> <li><code>rule_id: Optional[str]</code></li> <li><code>policy_id: Optional[str]</code></li> <li><code>reason: Optional[str]</code></li> </ul>"},{"location":"api/#yaml-policies","title":"YAML policies","text":"<p>All built-in policy sources accept JSON and, with the optional <code>rbacx[yaml]</code> extra, YAML.</p> <ul> <li>File: detected by extension <code>.yaml</code> / <code>.yml</code>.</li> <li>HTTP: detected by <code>Content-Type</code> (e.g., <code>application/yaml</code>, <code>application/x-yaml</code>, <code>text/yaml</code>) or URL suffix.</li> <li>S3: detected by key suffix <code>.yaml</code> / <code>.yml</code>.</li> </ul> <p>Internally YAML is parsed and validated against the same JSON Schema as JSON.</p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart LR\n  UI[Frameworks (FastAPI / Flask / Django / DRF / Starlette)] --&gt;|adapters| Core\n  Storage[Policy Sources (FS / HTTP(S) / S3)] --&gt;|PolicySource| Core\n  Roles[Role Resolver] --&gt;|RoleResolver| Core\n  Rel[Relationship Store (Local / SpiceDB / OpenFGA)] --&gt;|RelationshipChecker| Core\n  Oblig[Obligations] --&gt;|ObligationChecker| Core\n  Telemetry[Decision Logger] --&gt;|DecisionLogSink| Core\n  Metrics[Metrics] --&gt;|MetricsSink| Core\n  Cache[(Cache)] --- Core\n  Reloader[HotReloader] --&gt;|watch &amp; reload| Storage\n  Reloader --&gt; Core\n  Core[rbacx.core: Guard / Policy / Obligations]</code></pre>"},{"location":"audit_mode/","title":"Audit mode","text":"<p>RBACX can log authorization decisions for observability without enforcing them.</p>"},{"location":"audit_mode/#how-it-works","title":"How it works","text":"<ul> <li>Pass a <code>DecisionLogSink</code> implementation (e.g., <code>DecisionLogger</code>) to <code>Guard</code> via <code>logger_sink=...</code>.</li> <li>Each decision is emitted to the Python logger <code>rbacx.audit</code>. Set <code>as_json=True</code> to serialize the event as JSON; otherwise a compact text form (<code>decision {...}</code>) is logged. You can also control the log level via the <code>level</code> parameter.</li> <li>Optional sampling: either a single global <code>sample_rate</code> or smart sampling (<code>smart_sampling=True</code>) with category rates for <code>deny</code>, <code>permit_with_obligations</code>, <code>permit</code>.</li> <li>Redactions: pass explicit <code>redactions</code> or enable default redactions with <code>use_default_redactions=True</code>.</li> <li>Size bound: set <code>max_env_bytes</code> to cap serialized env after redactions.</li> <li>Redactions reuse obligation formats (e.g. <code>\"mask_fields\"</code>, <code>\"redact_fields\"</code>) and are applied before the event is logged; if a listed field is missing in the request context, the enforcer will still create it in the logged <code>env</code> with the appropriate placeholder (mask or <code>[REDACTED]</code>).</li> <li> <p>Redaction mode: <code>DecisionLogger</code> forwards <code>redact_in_place</code> to the enforcer:</p> </li> <li> <p><code>redact_in_place=False</code> (default) \u2014 redact on a copy of <code>env</code> (non-mutating, safer by default).</p> </li> <li><code>redact_in_place=True</code> \u2014 redact in place (fewer allocations; mutates the original <code>env</code>).     Choose copy-by-default unless you explicitly need in-process sanitization with lower allocation pressure. This aligns with common guidance to avoid sensitive data in logs and use masking/redaction when needed.</li> <li>Prefer structured logging (e.g., JSON) and include enough context for auditability (what/when/where/source/outcome/actor) per typical audit record guidance.</li> </ul>"},{"location":"audit_mode/#example-framework-agnostic","title":"Example (framework-agnostic)","text":"<pre><code>import logging\nfrom rbacx import Guard\nfrom rbacx.logging.decision_logger import DecisionLogger\n\naudit = logging.getLogger(\"rbacx.audit\")\naudit.setLevel(logging.INFO)\naudit.addHandler(logging.StreamHandler())\n\ndecision_logger = DecisionLogger(\n    as_json=True,\n    use_default_redactions=True,                 # opt-in safe defaults\n    smart_sampling=True,                         # category-aware sampling\n    sample_rate=0.05,                            # fallback for plain permits\n    category_sampling_rates={\"permit\": 0.05},    # leave deny/obligations at 1.0 (defaults)\n    level=logging.INFO,\n    redact_in_place=False,                       # set True only if you own the original env\n    # optional size bound after redactions:\n    max_env_bytes=64 * 1024,\n)\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": []}\nguard = Guard(policy, logger_sink=decision_logger)\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks helper","text":"<p>Run the included micro-benchmark to compare PDP latency for different policy sizes:</p> <pre><code>python bench/bench_pdp.py --sizes 10 100 500 1000 --iters 500\n</code></pre> <p>It prints CSV to stdout (<code>size,avg_ms,p50_ms,p90_ms,allowed</code>). Use it only for relative comparisons in your environment.</p>"},{"location":"caching/","title":"Decision Caching","text":"<p>Decision caching speeds up repeated authorization checks by storing final <code>Guard</code> decisions for a short time (TTL). This reduces latency and load on your policy and attribute sources, especially for \u201chot\u201d endpoints. Caching is optional and configured per <code>Guard</code> instance.</p>"},{"location":"caching/#current-capabilities","title":"Current capabilities","text":"<ul> <li>Optional, per-Guard. Caching is disabled by default; you enable it explicitly in the <code>Guard</code> constructor.</li> <li>Pluggable interface. Any implementation compatible with <code>AbstractCache</code> can be used; a simple in-memory LRU+TTL implementation is available for single-process scenarios.</li> <li>TTL on write. Controlled with the <code>cache_ttl</code> parameter (seconds).</li> <li>Automatic invalidation on policy updates. When the policy changes, the cache is cleared to avoid serving decisions produced by outdated rules.</li> <li>Manual clear. Use <code>guard.clear_cache()</code> to purge cached decisions proactively.</li> </ul> <p>Note: the in-memory cache works within a single process/worker. For multi-process or distributed deployments, use an external cache implementation \u2014 or keep caching disabled.</p>"},{"location":"caching/#quick-start","title":"Quick start","text":""},{"location":"caching/#enable-caching","title":"Enable caching","text":"<pre><code>from rbacx import Action, Context, Guard, Subject, Resource\nfrom rbacx.core.cache import DefaultInMemoryCache\n\npolicy = {\n    \"algorithm\": \"deny-overrides\",\n    \"rules\": [\n        {\n            \"id\": \"doc_read\",\n            \"effect\": \"permit\",\n            \"actions\": [\"read\"],\n            \"resource\": {\"type\": \"doc\", \"attrs\": {\"visibility\": [\"public\", \"internal\"]}},\n            \"condition\": {\"hasAny\": [ {\"attr\": \"subject.roles\"}, [\"reader\", \"admin\"] ]},\n            \"obligations\": [ {\"type\": \"require_mfa\"} ]\n        },\n        {\"id\": \"doc_deny_archived\", \"effect\": \"deny\", \"actions\": [\"*\"],\n         \"resource\": {\"type\": \"doc\", \"attrs\": {\"archived\": True}}}\n    ],\n}\n\ndefault_cache = DefaultInMemoryCache(maxsize=2048)\nguard = Guard(\n    policy=policy,\n    cache=default_cache,           # in-memory LRU for single-process setups\n    cache_ttl=300,                 # decision TTL in seconds\n)\n\ndecision = guard.evaluate_sync(\n    subject=Subject(id=\"u1\", roles=[\"reader\"]),\n    action=Action(\"read\"),\n    resource=Resource(type=\"doc\", id=\"42\", attrs={\"visibility\": \"public\"}),\n    context=Context(attrs={\"mfa\": True}),\n)\n\n# Manual cache purge if needed:\nguard.clear_cache()\n</code></pre>"},{"location":"caching/#when-it-clears-automatically","title":"When it clears automatically","text":"<ul> <li>On policy updates via the core API, to avoid serving decisions based on old rules.</li> </ul>"},{"location":"caching/#implementing-your-own-cache","title":"Implementing your own cache","text":"<p>A custom cache must conform to the <code>AbstractCache</code> protocol. Below is a description of what each method is expected to do (no external dependencies, no specific backend implied):</p> <ul> <li> <p><code>get(key: str) -&gt; Optional[Any]</code>   Return the stored decision for the given key, or <code>None</code> if the entry is missing or expired.   The key is an opaque string produced by <code>Guard</code>; do not parse or reinterpret it.</p> </li> <li> <p><code>set(key: str, value: Any, ttl: Optional[int]) -&gt; None</code>   Store the decision for the key and honor the TTL (seconds). If TTL is missing or non-positive, treat it as \u201cno expiration\u201d or follow your implementation\u2019s policy.   Ensure the value you store can be returned as-is by <code>get</code>.</p> </li> <li> <p><code>clear() -&gt; None</code>   Clear all entries for the current instance/namespace. The core uses this during policy replacement and for explicit manual clears.</p> </li> <li> <p>(optional) <code>delete(key: str)</code> / <code>invalidate(key: str)</code>   Targeted invalidation for a single key. Not required by the core (which relies on <code>clear()</code> and TTL), but may be useful in your environment.</p> </li> </ul>"},{"location":"caching/#implementation-notes-to-remain-stable-over-time","title":"Implementation notes (to remain stable over time)","text":"<ul> <li>Resilience. Cache errors must not break authorization. On failures, behave as if there\u2019s a miss (<code>get</code> returns <code>None</code>; <code>set/clear</code> swallow transient errors).</li> <li>Always respect TTL. TTL is the guardrail against stale decisions lingering indefinitely.</li> <li>Treat keys as a black box. Do not add semantics or derive data from keys. This keeps the cache robust to future key format changes.</li> <li>Data safety. Avoid placing sensitive data into keys or metadata, and be mindful of your infrastructure\u2019s visibility (logs, monitors, dumps).</li> <li>Scaling. For distributed backends, use stable serialization and predictable TTL semantics.</li> <li>Stampede mitigation. For \u201chot\u201d keys, consider small TTL jitter or a \u201cserve stale then revalidate\u201d approach to avoid synchronized expirations.</li> <li>Optional observability. If feasible, expose simple hit/miss and size indicators to tune TTL and capacity.</li> <li>Strict mode. With <code>strict_types=True</code>, the engine injects <code>__strict_types__</code> into the env, so cache keys differ from lax mode. See Types.</li> </ul>"},{"location":"caching/#best-practices-what-to-watch-for","title":"Best practices (what to watch for)","text":"<ul> <li>Prefer short TTLs for authorization. Rights and attributes change; short TTLs reduce the desynchronization window.</li> <li>Invalidate on policy change. The core already performs automatic clearing \u2014 keep it enabled.</li> <li>Do not rely on the cache for correctness. Decisions must be computed correctly without a cache; caching is an optimization only.</li> <li>Mitigate cache stampedes. Use TTL jitter and/or serve-stale-then-revalidate for hot keys; avoid synchronized expiry of many entries at once.</li> <li>Be cautious with negative caching. Caching <code>deny</code> improves load but may widen the \u201cfalse deny\u201d window immediately after granting new rights.</li> <li>Scope &amp; safety. In-memory cache scope is a single process; external caches require proper access controls and data lifecycle policies.</li> </ul>"},{"location":"ci/","title":"CI","text":"<p>Suggested checks: - Tests: <code>pytest -q</code> - Lint: <code>ruff check</code> - Types: <code>mypy src</code> - Build: <code>python -m build</code> (sdist + wheel)</p>"},{"location":"custom_policy_source/","title":"Creating a Custom <code>PolicySource</code> (concise + best practices)","text":"<p>RBACX accepts any object that implements the <code>PolicySource</code> protocol:</p> <pre><code>class PolicySource(Protocol):\n    def load(self) -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]: ...\n    def etag(self) -&gt; Optional[str] | Awaitable[Optional[str]]: ...\n</code></pre> <p>Built-ins: File, HTTP (sync), and S3 (sync) sources already ship with RBACX. But you can write your own \u2014 including async sources. This page keeps one small example (in-memory) and focuses on how to design your own source robustly.</p>"},{"location":"custom_policy_source/#minimal-in-memory-source","title":"Minimal in-memory source","text":"<pre><code>from typing import Any, Dict, Optional\nfrom rbacx import HotReloader, Guard\nfrom rbacx.core.ports import PolicySource\n\nclass MemorySource(PolicySource):\n    def __init__(self, policy: Dict[str, Any], etag: str = \"v1\"):\n        self._policy = policy\n        self._etag = etag\n\n    def etag(self) -&gt; Optional[str]:\n        # Return a cheap, stable version for the current policy\n        return self._etag\n\n    def load(self) -&gt; Dict[str, Any]:\n        # Return a dict representing a Policy or PolicySet\n        return self._policy\n\n# Usage\nguard = Guard(policy={\"rules\": []})\nsrc = MemorySource(policy={\n    \"rules\": [\n        {\"id\": \"allow_read\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}, \"effect\": \"permit\"}\n    ]\n}, etag=\"v2\")\nreloader = HotReloader(guard, src, initial_load=True)  # loads immediately when etag differs\n</code></pre>"},{"location":"custom_policy_source/#design-guidelines-what-good-sources-do","title":"Design guidelines (what good sources do)","text":"<ul> <li> <p>Cheap/stable versioning via <code>etag()</code></p> </li> <li> <p>Return a value that changes only when the policy changes (hash, version id, last-modified, etc.).</p> </li> <li> <p>Prefer values your backend already guarantees (e.g., HTTP <code>ETag</code>, S3 <code>VersionId</code>). If not available, compute one (e.g., hash) in <code>load()</code> and cache it. For HTTP, <code>ETag</code> and conditional requests (<code>If-None-Match</code> \u2192 <code>304 Not Modified</code>) minimize transfer and are standard practice.</p> </li> <li> <p>Deterministic <code>load()</code></p> </li> <li> <p>Always return a fully parsed <code>dict</code> (Policy or PolicySet), never partially filled structures.</p> </li> <li> <p>Validate input if you transform from YAML \u2192 JSON, and fail fast on invalid schema.</p> </li> <li> <p>Resilience &amp; fairness</p> </li> <li> <p>For remote backends: use timeouts, retries, exponential backoff with jitter, and a max backoff cap.</p> </li> <li> <p>Surface meaningful exceptions in logs; don\u2019t swallow permanent errors.</p> </li> <li> <p>Integrity &amp; security</p> </li> <li> <p>Verify payload integrity when possible (signed artifact, checksum, or versioned objects).</p> </li> <li>Secure transport: TLS; consider mTLS / pinning for internal services.</li> <li> <p>For HTTP caches/validators, see HTTP semantics (RFC 9110) for strong/weak validators and conditional requests. </p> </li> <li> <p>Sensible defaults</p> </li> <li> <p>If <code>etag()</code> can\u2019t be computed upfront, return <code>None</code>; <code>HotReloader</code> will still call <code>load()</code> when forced or on scheduled runs.</p> </li> <li>Keep <code>load()</code> side-effect free (no writes).</li> </ul>"},{"location":"custom_policy_source/#async-sources-with-httpx-example","title":"Async sources with <code>httpx</code> (example)","text":"<p>RBACX\u2019s <code>HotReloader</code> supports both sync and async <code>PolicySource</code> implementations. Below is a production-style async HTTP source using <code>httpx</code>:</p> <ul> <li>Uses <code>httpx.AsyncClient</code> with explicit timeouts. Default HTTPX timeouts are \\~5s of inactivity; set your own per your SLOs. </li> <li>Supports ETag caching and conditional GET via <code>If-None-Match</code> to receive <code>304 Not Modified</code> when the policy hasn\u2019t changed. </li> <li>Implements capped exponential backoff with jitter on transient failures \u2014 no extra dependencies.</li> </ul> <pre><code>import asyncio\nimport json\nimport math\nimport random\nfrom typing import Any, Dict, Optional\n\nimport httpx  # pip install https\n\nfrom rbacx.core.ports import PolicySource\n\n\nclass AsyncHTTPPolicySource(PolicySource):\n    \"\"\"\n    Async PolicySource that fetches a JSON policy from an HTTP endpoint.\n\n    - Caches ETag and last good policy in-memory.\n    - Uses conditional requests (If-None-Match) to avoid re-downloading unchanged payloads.\n    - Applies capped exponential backoff with jitter on transient errors.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        timeout: float = 5.0,\n        max_retries: int = 3,\n        backoff_base: float = 0.5,\n        backoff_cap: float = 8.0,\n        http2: bool = False,\n        verify: bool | str = True,\n    ) -&gt; None:\n        self._url = url\n        self._timeout = timeout\n        self._max_retries = max_retries\n        self._backoff_base = backoff_base\n        self._backoff_cap = backoff_cap\n        self._etag: Optional[str] = None\n        self._cached_policy: Optional[Dict[str, Any]] = None\n        self._client = httpx.AsyncClient(http2=http2, verify=verify)\n\n    async def close(self) -&gt; None:\n        await self._client.aclose()\n\n    # ---- PolicySource API -------------------------------------------------\n\n    async def etag(self) -&gt; Optional[str]:\n        # If we've seen an ETag before, return it cheaply.\n        if self._etag is not None:\n            return self._etag\n        # Otherwise, try to fetch headers via a HEAD; fallback to GET if HEAD not allowed.\n        try:\n            r = await self._client.head(self._url, timeout=self._timeout)\n            if r.status_code == 405:  # Method Not Allowed -&gt; fall back to GET headers\n                r = await self._client.get(self._url, headers={\"Range\": \"bytes=0-0\"}, timeout=self._timeout)\n            r.raise_for_status()\n            et = r.headers.get(\"ETag\")\n            if et:\n                self._etag = et\n            return self._etag\n        except Exception:\n            # If anything fails, signal unknown etag; the reloader can still force-load.\n            return None\n\n    async def load(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetch and parse the policy JSON. Uses If-None-Match to avoid full body when unchanged.\n        Retries transient failures with capped exponential backoff + jitter.\n        \"\"\"\n        last_etag = self._etag\n        headers = {\"Accept\": \"application/json\"}\n        if last_etag:\n            headers[\"If-None-Match\"] = last_etag\n\n        attempt = 0\n        while True:\n            try:\n                r = await self._client.get(self._url, headers=headers, timeout=self._timeout)\n                # 304: unchanged -&gt; return cached policy if available\n                if r.status_code == 304 and self._cached_policy is not None:\n                    return self._cached_policy\n\n                r.raise_for_status()\n                # Success path: parse JSON, update cache + etag\n                policy = r.json()\n                if not isinstance(policy, dict):\n                    raise ValueError(\"policy must be a JSON object\")\n                self._etag = r.headers.get(\"ETag\", self._etag)\n                self._cached_policy = policy\n                return policy\n\n            except (httpx.ConnectError, httpx.ReadTimeout, httpx.RemoteProtocolError, httpx.HTTPStatusError) as e:\n                # Retry on common transient network/protocol errors and 5xx responses\n                if isinstance(e, httpx.HTTPStatusError) and (400 &lt;= e.response.status_code &lt; 500) and e.response.status_code != 429:\n                    # Non-retryable 4xx (except 429)\n                    raise\n                attempt += 1\n                if attempt &gt; self._max_retries:\n                    raise\n                # Exponential backoff with full jitter\n                base = self._backoff_base * (2 ** (attempt - 1))\n                sleep_s = min(self._backoff_cap, base) * random.uniform(0.0, 1.0)\n                await asyncio.sleep(sleep_s)\n</code></pre> <p>Notes</p> <ul> <li>HTTP semantics for ETags and conditional requests: MDN (<code>ETag</code>, <code>If-None-Match</code>, <code>304</code>) and RFC 9110 are the authoritative references. </li> <li>HTTPX async client, timeouts, and options (e.g., <code>http2</code>, <code>verify</code>): see official docs. </li> <li>Backoff with jitter is recommended to avoid retry storms. </li> </ul>"},{"location":"custom_policy_source/#using-it-with-the-reloader","title":"Using it with the reloader","text":"<pre><code>from rbacx import Guard, HotReloader\n\nguard = Guard(policy={\"rules\": []})\nsrc = AsyncHTTPPolicySource(\"https://policies.example.com/current.json\", http2=True, timeout=3.0)\n\n# One-shot (sync), even inside an async app:\nchanged = HotReloader(guard, src).check_and_reload(force=True)  # the reloader handles event loop bridging\n\n# Or async:\n# changed = await HotReloader(guard, src).check_and_reload_async(force=True)\n</code></pre> <p>Cleanup: If you construct long-lived sources, remember to close the <code>AsyncClient</code> when done:</p> <pre><code>await src.close()\n</code></pre>"},{"location":"custom_policy_source/#operational-tips","title":"Operational tips","text":"<ul> <li>Polling: Pick an interval that fits your update cadence; add small random jitter to reduce thundering herds. For HTTP, prefer conditional requests so unchanged policies return <code>304 Not Modified</code>. </li> <li>Observability: Log failures with context (source, attempt, delay), add metrics (reload success/failure, last apply time).</li> <li>Circuit-breakers: If your backend is unstable, short-circuit after N attempts and try later.</li> <li>Rollouts: Version your policies; keep a quick rollback path (e.g., previous <code>VersionId</code> / artifact).</li> </ul>"},{"location":"custom_policy_source/#testing-your-source","title":"Testing your source","text":"<ul> <li>Unit: Prove <code>etag()</code> stability for no-change scenarios; verify change detection and that <code>load()</code> rejects malformed data.</li> <li>Integration: Exercise <code>HotReloader.check_and_reload(force=True)</code> and the background <code>start()/stop()</code> loop.</li> <li>Failure modes: Simulate timeouts/5xx and ensure backoff+jitter take effect and logs are clear. AWS guidance on timeouts/retries/jitter is a good reference. </li> </ul>"},{"location":"custom_policy_source/#checklist","title":"Checklist","text":"<ul> <li>[ ] <code>etag()</code> returns a cheap, stable value that changes only when policy changes (or <code>None</code> if unknown).</li> <li>[ ] <code>load()</code> returns a valid dict (Policy/PolicySet).</li> <li>[ ] Remote backends: timeouts, retries, exponential backoff with jitter, max cap.</li> <li>[ ] Integrity/security measures in place (versioning, checksums, signatures, TLS/mTLS).</li> <li>[ ] Good logs/metrics for visibility; clear rollback path.</li> </ul>"},{"location":"diagnostics/","title":"Policy diagnostics","text":"<p>RBACX provides two complementary diagnostics layers:</p> <ul> <li>Schema validation (<code>rbacx validate</code>) \u2014 checks that a policy (or each entry of a policy set) conforms to the official JSON Schema.</li> <li>Heuristic linting (<code>rbacx lint</code>) \u2014 analyzes policy structure for common authoring pitfalls beyond the schema.</li> <li>One-shot convenience (<code>rbacx check</code>) \u2014 runs validation first and, only if valid, runs the linter on the same input.</li> </ul> <p>The linter is intentionally heuristic. It aims for high-signal checks without heavy symbolic reasoning.</p>"},{"location":"diagnostics/#commands","title":"Commands","text":""},{"location":"diagnostics/#rbacx-validate","title":"<code>rbacx validate</code>","text":"<p>Validate a single policy document or each member of a policy set against the JSON Schema.</p>"},{"location":"diagnostics/#rbacx-lint","title":"<code>rbacx lint</code>","text":"<p>Run non-schema checks that flag risky or inconsistent authoring patterns.</p>"},{"location":"diagnostics/#rbacx-check","title":"<code>rbacx check</code>","text":"<p>Run validate \u2192 lint in one pass. If validation fails, linting is skipped.</p>"},{"location":"diagnostics/#inputs-outputs","title":"Inputs &amp; outputs","text":""},{"location":"diagnostics/#inputs","title":"Inputs","text":"<ul> <li><code>--policy PATH|-</code> \u2014 path to a JSON/YAML file. Use <code>-</code> or omit the flag to read from STDIN.</li> <li><code>--policyset</code> \u2014 interpret the input as a policy set (expects top-level <code>policies: [...]</code>).</li> </ul>"},{"location":"diagnostics/#outputs","title":"Outputs","text":"<ul> <li><code>--format json|text</code> \u2014 output format (default: <code>json</code>).</li> <li><code>--strict</code> \u2014 for lint/check: return a non\u2011zero exit code when any lint issues are found.</li> </ul>"},{"location":"diagnostics/#lintspecific","title":"Lint\u2011specific","text":"<ul> <li><code>--require-attrs \"subject:id,org;resource:type;:a,b\"</code> \u2014 require that certain attribute keys appear in conditions by entity.   Entities: <code>subject</code>, <code>resource</code>, <code>action</code>, or empty for \u201cany\u201d. Right\u2011hand side is a comma\u2011separated list of required keys.</li> </ul>"},{"location":"diagnostics/#exit-codes","title":"Exit codes","text":"Code Meaning 0 OK 2 Usage error (bad arguments) 3 Lint issues found (only with <code>--strict</code>) 4 I/O error (file not found, decoding error) 5 Missing optional dependency (e.g., YAML or JSON Schema engine) 6 Schema validation errors"},{"location":"diagnostics/#lint-checks","title":"Lint checks","text":"<p>RBACX ships a simple linter to catch common authoring pitfalls:</p> <ul> <li>MISSING_ID \u2014 each rule should have a stable <code>id</code> for auditing.</li> <li>DUPLICATE_ID \u2014 rule ids must be unique within a policy.</li> <li>EMPTY_ACTIONS \u2014 avoid rules without actions.</li> <li>BROAD_RESOURCE \u2014 <code>resource.type</code> is <code>*</code> or missing; narrow the scope.</li> <li>POTENTIALLY_UNREACHABLE \u2014 with <code>first-applicable</code>, a later rule is shadowed because an earlier one with the same effect already covers its actions/resource.</li> <li>ALWAYS_TRUE \u2014 the condition is trivially true (e.g., <code>{\"==\":[X, X]}</code>); the rule may be overly broad.</li> <li>ALWAYS_FALSE \u2014 the condition is trivially false (e.g., <code>{\"!=\":[X, X]}</code>); the rule will never match.</li> </ul> <p>We intentionally avoid a generic <code>regex</code> operator to reduce ReDoS risk. If you add regex matching, prefer safe engines (like RE2) and enforce timeouts.</p>"},{"location":"diagnostics/#examples","title":"Examples","text":""},{"location":"diagnostics/#validate","title":"Validate","text":"<pre><code># Single policy (from file)\nrbacx validate --policy policy.json\n\n# Policy set (top-level \"policies\")\nrbacx validate --policy policies.yaml --policyset\n\n# Read from STDIN\ncat policy.json | rbacx validate --policy -\n\n# Human-readable\nrbacx validate --policy policy.json --format text\n</code></pre> <p>Output semantics - JSON: <code>[]</code> when valid, otherwise a list of error objects; for policy sets, each error may include <code>policy_index</code>. - Text: prints <code>OK</code> when valid; otherwise one <code>SCHEMA</code> line per error, optionally with <code>[policy_index=N]</code>.</p>"},{"location":"diagnostics/#lint","title":"Lint","text":"<pre><code># Lint a single policy\nrbacx lint --policy policy.json\n\n# Lint a policy set\nrbacx lint --policy policies.yaml --policyset\n\n# Human\u2011readable and strict (CI)\nrbacx lint --policy policy.json --format text --strict\n\n# Require attributes to appear in conditions\nrbacx lint --policy policy.json --require-attrs \"subject:id,org;resource:type\"\n</code></pre> <p>Output semantics - JSON: a list of issue objects. Typical fields: <code>code</code>, <code>message</code>, <code>path</code>, <code>policy_index</code> (for sets). - Text: one line per issue, e.g. <code>MISSING_ID [policy_index=0] rules[2].id: each rule should have a stable id</code></p>"},{"location":"diagnostics/#check-validate-lint","title":"Check (validate \u2192 lint)","text":"<pre><code># Validate and lint in one go\nrbacx check --policy policy.json\n\n# CI\u2011friendly policy set run\nrbacx check --policy policies.yaml --policyset --format text --strict\n\n# With STDIN\ncat policy.json | rbacx check --policy - --require-attrs \"subject:id,org\"\n</code></pre> <p>Behavior - If validation produces any errors, the command exits with <code>6</code> (SCHEMA_ERRORS) and does not run lint. - If validation passes, lint runs and prints issues; with <code>--strict</code>, the exit code is <code>3</code> (LINT_ERRORS) when issues are found.</p>"},{"location":"diagnostics/#ci-recommendations","title":"CI recommendations","text":"<pre><code># Fail the build on schema or lint problems, with readable logs\nrbacx check --policy policy.json --format text --strict\n# or:\nrbacx validate --policy policy.json --format text\nrbacx lint --policy policy.json --format text --strict\n</code></pre>"},{"location":"highlights/","title":"Highlights of RBACX","text":""},{"location":"highlights/#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>Core vs. Adapters: Authorization decision logic lives in <code>rbacx.core</code> (e.g., <code>Guard</code>), while framework-specific integration is implemented as adapters (FastAPI, Django, Flask, DRF, Starlette/Litestar). This separation keeps the core framework-agnostic.</li> <li>Ports/Interfaces: Core depends on abstract ports (sync/async-friendly; e.g., <code>RoleResolver</code>, <code>DecisionLogSink</code>, <code>MetricsSink</code>, <code>ObligationChecker</code>) enabling custom implementations without modifying the core.</li> <li>Security defaults: The default combining algorithm is <code>deny-overrides</code> (deny-by-default). Other algorithms: <code>permit-overrides</code>, <code>first-applicable</code>.</li> <li>ReBAC port: Optional <code>RelationshipChecker</code> in <code>rbacx.core.ports</code> with ready-to-use implementations: <code>LocalRelationshipChecker</code>, <code>SpiceDBChecker</code>, <code>OpenFGAChecker</code>. Enables relationship-based checks (subject \u2014relation\u2192 resource) alongside RBAC/ABAC.</li> </ul>"},{"location":"highlights/#policy-model-json","title":"Policy Model (JSON)","text":"<ul> <li>Entities: <code>Subject</code>, <code>Resource</code>, <code>Action</code>, plus optional context.</li> <li>Rules &amp; Effects: Each rule defines conditions and an <code>effect</code> (Permit/Deny).</li> <li>Combining algorithms: <code>deny-overrides</code> (default), <code>permit-overrides</code>, <code>first-applicable</code>.</li> <li>Conditions: comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, etc.), collection operations (<code>hasAny</code>, <code>hasAll</code>), membership (<code>in</code>, <code>contains</code>), and time operators (<code>before</code>, <code>after</code>, <code>between</code>).</li> <li>Relationship conditions (ReBAC): <code>rel</code> operator for graph/relationship checks.   Short form: <code>{\"rel\": \"owner\"}</code> (uses current subject/resource).   Extended: <code>{\"rel\": {\"relation\": \"editor\", \"subject\": \"...\", \"resource\": \"...\", \"ctx\": {...}}}</code>.   If <code>subject</code>/<code>resource</code> omitted, engine uses inputs; <code>ctx</code> is merged into <code>context._rebac</code>. If no <code>RelationshipChecker</code> is configured, <code>rel</code> evaluates to <code>false</code> (fail-closed).</li> <li>Obligations: actions to perform on Permit decisions (e.g., require MFA, log an event).</li> </ul>"},{"location":"highlights/#integration","title":"Integration","text":"<ul> <li>Frameworks: Adapters for FastAPI, Flask, Django (incl. DRF), Starlette/Litestar.</li> <li>Enforcement: Dependencies/middleware/decorators (e.g., <code>rbacx.adapters.fastapi.require_access</code>) to guard endpoints, views, or request pipelines.</li> <li>Role Resolution: Pluggable role resolvers (e.g., static role inheritance with <code>StaticRoleResolver</code>).</li> <li>Enable ReBAC: Pass <code>relationship_checker=</code> to <code>Guard(...)</code>. Sync/async implementations are supported; framework adapters do not require changes.</li> </ul>"},{"location":"highlights/#policy-loading-reloading","title":"Policy Loading &amp; Reloading","text":"<ul> <li>Sources: Filesystem, HTTP(S), AWS S3.</li> </ul>"},{"location":"highlights/#observability-tooling","title":"Observability &amp; Tooling","text":"<ul> <li>Decision Introspection: Decision objects expose fields such as <code>allowed</code>, <code>effect</code>, <code>reason</code>, <code>rule_id</code>, enabling audit and explainability.</li> <li>Metrics &amp; Logging: Sinks for Prometheus / OpenTelemetry and structured logging are pluggable via ports.</li> <li>Linting: Policy linter/CLI to validate policy consistency before/at runtime.</li> </ul>"},{"location":"highlights/#testing","title":"Testing","text":"<ul> <li>Coverage: Meets industry standards. Approximately 80+% of the codebase.</li> <li>Scope: Tests cover decision logic, rule combining, ABAC operators (including time and collection ops), obligations, policy loading/reloading, and linting.</li> </ul>"},{"location":"highlights/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Internal indexing/compilation of policies to quickly skip irrelevant rules (e.g., by resource type).</li> <li>Stateless <code>Guard</code> suitable for horizontal scaling; shared policy sources (e.g., S3/file) can be used across instances.</li> <li>Documentation includes guidance on avoiding overly broad conditions and caching expensive context computations.</li> <li>ReBAC checks: Relationship lookups are memoized within a single decision; backends may implement <code>batch_check(...)</code> to reduce round-trips for bulk evaluations.</li> </ul>"},{"location":"highlights/#compatibility","title":"Compatibility","text":"<ul> <li>Python: see project metadata (pyproject.toml).</li> <li>Frameworks: FastAPI, Flask, Django/DRF, Starlette/Litestar (via adapters).</li> </ul>"},{"location":"highlights/#async-support","title":"Async support","text":"<ul> <li><code>Guard</code> provides both <code>evaluate_sync(...)</code> and <code>evaluate_async(...)</code>. Injected ports (resolver, obligations, metrics, logger) can be synchronous or asynchronous; both forms are supported.</li> <li><code>HotReloader</code> provides <code>check_and_reload(...)</code> (sync) and <code>check_and_reload_async(...)</code> (async) and accepts <code>PolicySource</code> implementations with sync or async <code>load()</code>/<code>etag()</code>.</li> </ul>"},{"location":"http_mapping/","title":"Mapping Decision reasons to HTTP responses","text":"<p>A common mapping when using RBACX in web apps:</p> Decision / reason HTTP code Notes <code>permit</code> 200/204 Proceed <code>explicit_deny</code> 403 Hard deny <code>no_match</code> / <code>no_match_policy</code> 403 Deny-by-default <code>condition_mismatch</code> 403 Policy matched but condition evaluated to False <code>condition_type_mismatch</code> 500 Authoring/data issue; investigate <code>obligation_failed</code> 403 (or 401 if an auth challenge) Permit was gated by obligations (e.g., MFA) and they were not fulfilled or failed verification. If the decision includes a <code>challenge</code> tied to authentication, you MAY return 401 and include the appropriate challenge header; otherwise return 403. <code>action_mismatch</code> 403 Rule exists but does not cover the action <code>resource_mismatch</code> 404/403 Prefer 404 for resource hiding; otherwise 403 <p>See OWASP guidance on logging and monitoring for how to record failures without leaking sensitive info.</p>"},{"location":"logging/","title":"Logging configuration","text":"<p>RBACX uses Python's standard <code>logging</code> and does not configure handlers for you.</p>"},{"location":"logging/#console-logging-dictconfig","title":"Console logging (dictConfig)","text":"<pre><code>import logging.config\nLOGGING = {\n  \"version\": 1,\n  \"disable_existing_loggers\": False,\n  \"formatters\": {\"console\": {\"format\": \"%(asctime)s %(levelname)s %(name)s: %(message)s\"}},\n  \"handlers\": {\"console\": {\"class\": \"logging.StreamHandler\", \"formatter\": \"console\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre>"},{"location":"logging/#rotating-file-logs","title":"Rotating file logs","text":"<pre><code>import logging.config\nLOGGING = {\n  \"version\": 1, \"disable_existing_loggers\": False,\n  \"formatters\": {\"plain\": {\"format\": \"%(asctime)s %(levelname)s %(name)s: %(message)s\"}},\n  \"handlers\": {\"file\": {\"class\": \"logging.handlers.RotatingFileHandler\", \"filename\": \"app.log\", \"maxBytes\": 5_000_000, \"backupCount\": 3, \"encoding\": \"utf-8\", \"formatter\": \"plain\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"file\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre>"},{"location":"logging/#json-logs-python-json-logger","title":"JSON logs (python-json-logger)","text":"<p><pre><code>pip install \"rbacx[jsonlog]\"\n</code></pre> <pre><code>import logging.config\nLOGGING = {\n  \"version\": 1, \"disable_existing_loggers\": False,\n  \"formatters\": {\"json\": {\"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\", \"format\": \"%(asctime)s %(levelname)s %(name)s %(message)s %(trace_id)s\"}},\n  \"handlers\": {\"console\": {\"class\": \"logging.StreamHandler\", \"formatter\": \"json\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre></p>"},{"location":"logging/#request-tracing-trace_id","title":"Request tracing (trace_id)","text":"<p>Use <code>rbacx.logging.context.TraceIdFilter</code> to inject <code>trace_id</code> into records. - ASGI (FastAPI, Litestar): <code>rbacx.adapters.asgi_logging.TraceIdMiddleware</code>. - Django: <code>rbacx.adapters.django.trace.TraceIdMiddleware</code>. - Flask: hooks in the example manage <code>X-Request-ID</code> header.</p>"},{"location":"logging/#rbacx-decision-logger-audit-sink","title":"RBACX Decision Logger (audit sink)","text":"<p><code>rbacx.logging.decision_logger.DecisionLogger</code> implements the <code>DecisionLogSink</code> port. It can emit decision events either as text or JSON and supports sampling and redactions.</p> <p>Options: - <code>sample_rate: float</code> \u2014 probability in [0..1] to log the event (legacy single-rate sampling). - <code>redactions: list[dict]</code> \u2014 obligations-style redactions applied to <code>env</code> before logging. If provided (even <code>[]</code>), it is used exclusively. - <code>use_default_redactions: bool</code> \u2014 when <code>True</code> and <code>redactions</code> is not provided, apply a conservative default set via the enforcer. - <code>smart_sampling: bool</code> \u2014 enable category-aware sampling (<code>deny</code>, <code>permit_with_obligations</code>, <code>permit</code>). - <code>category_sampling_rates: dict[str, float]</code> \u2014 per-category probabilities; unspecified categories fall back to <code>sample_rate</code>. - <code>max_env_bytes: int</code> \u2014 cap the serialized size of the (already redacted) env; on exceed logs <code>{\"_truncated\": true, \"size_bytes\": N}</code>. - <code>as_json: bool</code> \u2014 when <code>True</code>, serialize the event to JSON; otherwise logs as <code>\"decision {payload}\"</code>. - <code>level: int</code> \u2014 Python logging level used for the event (defaults to <code>logging.INFO</code>). - <code>redact_in_place: bool = False</code> \u2014 controls how redactions are applied to env:   - <code>False</code> (default): redact on a copy (no mutation of the original environment).   - <code>True</code>: redact in place (fewer allocations; mutates the original env).</p> <p>Examples: <pre><code>import logging\nfrom rbacx.logging.decision_logger import DecisionLogger\n\naudit = logging.getLogger(\"rbacx.audit\")\naudit.setLevel(logging.INFO)\naudit.addHandler(logging.StreamHandler())\n\nlogger_sink = DecisionLogger(\n    sample_rate=0.1,  # about 10% of events will be logged\n    as_json=True,\n    level=logging.INFO,\n    redactions=[{\"type\": \"mask_fields\", \"fields\": [\"subject.attrs.ssn\"], \"placeholder\": \"***\"}],\n)\n\n# In-place redaction (mutates env), useful to minimize allocations on hot paths\ninplace_sink = DecisionLogger(\n    sample_rate=1.0,\n    as_json=True,\n    level=logging.INFO,\n    redactions=[{\"type\": \"redact_fields\", \"fields\": [\"resource.attrs.secret\"]}],\n    redact_in_place=True,  # mutate env instead of copying\n)\n</code></pre></p> <p>Redaction priority: <code>redactions</code> (if provided) \u2192 <code>use_default_redactions=True</code> \u2192 no redactions.</p>"},{"location":"logging/#example-opt-in-defaults-smart-sampling-size-bound","title":"Example: opt-in defaults + smart sampling + size bound","text":"<pre><code>from rbacx.logging.decision_logger import DecisionLogger\nsink = DecisionLogger(\n    as_json=True,\n    use_default_redactions=True,          # mask common PII/secrets via enforcer\n    smart_sampling=True,                  # always log deny and permit-with-obligations\n    sample_rate=0.05,                     # fallback for plain permits\n    category_sampling_rates={\"permit\": 0.05},\n    max_env_bytes=64 * 1024,              # bound serialized env size after redactions\n)\n</code></pre>"},{"location":"logging/#default-redaction-set","title":"Default redaction set","text":"<p>Used only when <code>use_default_redactions=True</code> and <code>redactions</code> is not provided. <code>redact_fields</code> values are replaced with <code>\"[REDACTED]\"</code>; <code>mask_fields</code> values use the placeholder <code>\"***\"</code>.</p> <ul> <li> <p><code>redact_fields</code> \u2192 <code>\"[REDACTED]\"</code>:</p> </li> <li> <p><code>subject.attrs.password</code></p> </li> <li><code>subject.attrs.token</code></li> <li><code>subject.attrs.mfa_code</code></li> <li><code>subject.attrs.email</code></li> <li><code>subject.attrs.phone</code></li> <li><code>resource.attrs.secret</code></li> <li><code>context.headers.authorization</code></li> <li> <p><code>context.cookies</code> (the whole cookies object is redacted)</p> </li> <li> <p><code>mask_fields</code> \u2192 <code>\"***\"</code>:</p> </li> <li> <p><code>context.ip</code></p> </li> </ul>"},{"location":"metrics/","title":"Metrics integration","text":"<p>RBACX can emit metrics via Prometheus or OpenTelemetry.</p>"},{"location":"metrics/#prometheus","title":"Prometheus","text":"<p>Use <code>PrometheusMetrics</code> sink (requires <code>prometheus_client</code>). Exposes: - <code>rbacx_decisions_total{allowed,reason}</code> \u2014 counter of decisions. - <code>rbacx_decision_duration_seconds</code> \u2014 histogram (adapters can observe latency).</p>"},{"location":"metrics/#opentelemetry","title":"OpenTelemetry","text":"<p>Use <code>OpenTelemetryMetrics</code> (requires <code>opentelemetry-api</code>). Creates instruments: - Counter <code>rbacx.decisions</code> (attributes: <code>allowed</code>, <code>reason</code>). - Histogram <code>rbacx.decision.duration.ms</code>.</p> <p>See OpenTelemetry Metrics API and Prometheus client docs for details. </p>"},{"location":"migration_rbac_to_abac/","title":"Migrating from RBAC to ABAC","text":"<p>This guide outlines pragmatic steps to evolve from role-based access control (RBAC) to attribute-based access control (ABAC).</p>"},{"location":"migration_rbac_to_abac/#1-inventory-roles-permissions","title":"1) Inventory roles &amp; permissions","text":"<p>Export your current RBAC roles and permissions; identify hotspots (over-privileged roles, cross-cutting exceptions).</p>"},{"location":"migration_rbac_to_abac/#2-identify-key-attributes","title":"2) Identify key attributes","text":"<p>Subject attributes (department, clearance), resource attributes (owner, tenant, classification), and environmental (time, geo). See NIST SP 800-162 for ABAC components and considerations.</p>"},{"location":"migration_rbac_to_abac/#3-start-with-deny-by-default","title":"3) Start with deny-by-default","text":"<p>Adopt <code>deny-overrides</code> and add explicit permits. Keep policies small and typed (resource.type).</p>"},{"location":"migration_rbac_to_abac/#4-express-exceptions-as-attributes","title":"4) Express exceptions as attributes","text":"<p>Turn ad-hoc role exceptions into ABAC rules (e.g., owner-based access). Prefer small, composable conditions.</p>"},{"location":"migration_rbac_to_abac/#5-dual-run-with-audit-mode","title":"5) Dual-run with audit-mode","text":"<p>Run PDP in audit mode alongside enforcement; compare <code>Decision.reason</code> and logs to detect gaps before enforcing.</p>"},{"location":"migration_rbac_to_abac/#6-decompose-roles","title":"6) Decompose roles","text":"<p>Gradually replace monolithic roles by attributes; maintain role hierarchy if needed (resolver) while transitioning.</p>"},{"location":"migration_rbac_to_abac/#7-validate-lint","title":"7) Validate &amp; lint","text":"<p>Use JSON Schema validation and <code>rbacx lint</code> to catch issues (broad rules, unreachable rules, duplicates).</p>"},{"location":"migration_rbac_to_abac/#8-educate-and-document","title":"8) Educate and document","text":"<p>Keep a policy authoring playbook and examples; require unique rule IDs and reasons in reviews.</p> <p>References: - NIST SP 800-162 ABAC (definition, components, considerations) - ANSI/INCITS 359-2004 RBAC (roles, permissions, hierarchies) - XACML 3.0 combining algorithms (deny-/permit-overrides, first-applicable)</p>"},{"location":"obligations/","title":"Obligations &amp; Challenges","text":"<p>This page documents the built-in obligation types enforced by <code>BasicObligationChecker</code> and shows how to extend the checker with custom policies (e.g., geo-fencing). It also clarifies how to target obligations to a specific decision effect (<code>permit</code> vs <code>deny</code>) and how <code>challenge</code> hints are surfaced to the PEP layer.</p>"},{"location":"obligations/#compatibility","title":"Compatibility","text":"<p>The checker accepts both legacy and modern raw decision shapes:</p> <ul> <li>Legacy: <code>{\"decision\": \"permit\" | \"deny\", \"obligations\": [...]}</code></li> <li>Modern: <code>{\"effect\": \"permit\" | \"deny\", \"allowed\": bool, \"obligations\": [...]}</code></li> </ul> <p>Rules of thumb:</p> <ul> <li>Any non-<code>permit</code> decision fails closed: <code>(ok=False, challenge=None)</code>.</li> <li>When effect is <code>permit</code>, obligations targeted at <code>permit</code> are evaluated; if any fails, <code>(ok=False, challenge=...)</code>.</li> <li>Obligations can explicitly target an effect via <code>on: \"permit\" | \"deny\"</code>; those not matching the current effect are ignored.</li> </ul>"},{"location":"obligations/#obligations-targeting-deny","title":"Obligations targeting <code>deny</code>","text":"<p>Obligations may target the <code>deny</code> branch via <code>on: \"deny\"</code>. This is useful to surface a machine-readable <code>challenge</code> (e.g., <code>http_basic</code>) even when the PDP already decided to deny. The PEP can then translate it into <code>WWW-Authenticate</code> headers or other UX.</p>"},{"location":"obligations/#built-in-obligation-types","title":"Built-in obligation types","text":"<p>Unless noted, these apply when <code>on: \"permit\"</code>.</p> <ul> <li><code>require_mfa</code> \u2192 <code>challenge=\"mfa\"</code> when <code>context.attrs[\"mfa\"]</code> is falsy.</li> <li><code>require_level</code> (<code>attrs.min</code>) \u2192 <code>challenge=\"step_up\"</code> when <code>context.attrs[\"auth_level\"] &lt; min</code>.</li> <li><code>http_challenge</code> (<code>on: permit|deny</code>, <code>attrs.scheme</code> = <code>Basic|Bearer|Digest</code>) \u2192   <code>challenge=\"http_basic\" | \"http_bearer\" | \"http_digest\"</code>; unknown/omitted scheme \u2192 <code>http_auth</code>.</li> <li> <p><code>require_consent</code> (optional <code>attrs.key</code>) \u2192 <code>challenge=\"consent\"</code> when consent is missing.</p> </li> <li> <p>With a key: expect <code>context.attrs[\"consent\"][key] is True</code>.</p> </li> <li>Without a key: expect any truthy <code>context.attrs[\"consent\"]</code>.</li> <li><code>require_terms_accept</code> \u2192 <code>challenge=\"tos\"</code> when <code>context.attrs[\"tos_accepted\"]</code> is falsy.</li> <li><code>require_captcha</code> \u2192 <code>challenge=\"captcha\"</code> when <code>context.attrs[\"captcha_passed\"]</code> is falsy.</li> <li><code>require_reauth</code> (<code>attrs.max_age</code>) \u2192 <code>challenge=\"reauth\"</code> when <code>context.attrs[\"reauth_age_seconds\"] &gt; max_age</code>.</li> <li><code>require_age_verified</code> \u2192 <code>challenge=\"age_verification\"</code> when <code>context.attrs[\"age_verified\"]</code> is falsy.</li> </ul>"},{"location":"obligations/#policy-examples","title":"Policy examples","text":""},{"location":"obligations/#yaml-mfa-on-permit","title":"YAML \u2014 MFA on <code>permit</code>","text":"<pre><code># A permit rule that requires MFA before access is actually granted.\nobligations:\n  - on: permit\n    type: require_mfa\n</code></pre>"},{"location":"obligations/#json-http-challenge-on-deny","title":"JSON \u2014 HTTP challenge on <code>deny</code>","text":"<pre><code>{\n  \"obligations\": [\n    {\n      \"on\": \"deny\",\n      \"type\": \"http_challenge\",\n      \"attrs\": { \"scheme\": \"Basic\" }\n    }\n  ]\n}\n</code></pre>"},{"location":"obligations/#yaml-geo-fencing-custom-extension-example","title":"YAML \u2014 Geo-fencing (custom extension example)","text":"<pre><code># Example obligation we will implement via a custom checker:\n# Allow only if user's geo is in the allowed set.\nobligations:\n  - on: permit\n    type: require_geo\n    attrs:\n      allow: [\"EU\", \"US\"]\n</code></pre> <p>Expected context for geo: <code>context.attrs[\"geo\"]</code> should contain a short region code (e.g., <code>\"EU\"</code>, <code>\"US\"</code>, <code>\"APAC\"</code>).</p>"},{"location":"obligations/#extending-the-checker-custom-obligations","title":"Extending the checker (custom obligations)","text":"<p>To add your own obligation types (e.g., <code>require_geo</code>), subclass <code>BasicObligationChecker</code> and handle your <code>type</code>. Always call <code>super().check(...)</code> first to preserve built-ins and fail-closed semantics.</p> <pre><code># src/myapp/obligations.py\nfrom rbacx.core.obligations import BasicObligationChecker\n\nclass CustomObligationChecker(BasicObligationChecker):\n    def check(self, decision, context):\n        # Let the base checker evaluate built-ins first.\n        ok, ch = super().check(decision, context)\n        if not ok:\n            return ok, ch\n\n        # Determine current effect in the same manner as the base checker does:\n        effect = decision.get(\"effect\")\n        if effect is None:\n            effect = \"permit\" if decision.get(\"decision\") == \"permit\" else \"deny\"\n        if effect not in (\"permit\", \"deny\"):\n            effect = \"deny\"  # fail-closed\n\n        ctx = getattr(context, \"attrs\", context) or {}\n        obligations = decision.get(\"obligations\") or []\n\n        for ob in obligations:\n            if (ob or {}).get(\"on\", \"permit\") != effect:\n                continue\n            if (ob or {}).get(\"type\") == \"require_geo\":\n                allow_list = set(((ob.get(\"attrs\") or {}).get(\"allow\") or []))\n                if not allow_list:\n                    # No allow-list means fail-closed\n                    return False, \"geo\"\n                if ctx.get(\"geo\") not in allow_list:\n                    return False, \"geo\"\n\n        return True, None\n</code></pre> <p>Then wire your checker into the Guard (where you construct your PDP/PEP integration). The Guard should consume <code>(ok, challenge)</code> and, on failure, flip <code>permit \u2192 deny</code>, adding the <code>challenge</code> to the final <code>Decision</code>.</p>"},{"location":"obligations/#context-contract-quick-reference","title":"Context contract (quick reference)","text":"<p>The checker reads the following <code>context.attrs[...]</code> keys when relevant:</p> <ul> <li><code>mfa: bool</code></li> <li><code>auth_level: int</code></li> <li><code>consent: bool | {str: bool}</code></li> <li><code>tos_accepted: bool</code></li> <li><code>captcha_passed: bool</code></li> <li><code>reauth_age_seconds: int</code></li> <li><code>age_verified: bool</code></li> <li><code>geo: str</code> (custom example)</li> </ul>"},{"location":"obligations/#notes-best-practices","title":"Notes &amp; best practices","text":"<ul> <li>Keep obligation handlers pure (no I/O) and quick; they run in the request path.</li> <li>Use <code>on: \"deny\"</code> to add diagnostics/UX to denials (e.g., prompt client re-auth).</li> <li>When parsing numeric attrs (e.g., <code>min</code>, <code>max_age</code>), default invalid values to 0 and fail closed.</li> <li>Unknown <code>type</code> values should be treated as advice and ignored by the checker unless you explicitly implement them.</li> </ul>"},{"location":"observability_stack/","title":"Observability (Prometheus + Grafana) via Docker Compose","text":"<p>A ready-to-run stack lives in <code>deploy/compose/metrics</code>: - <code>app</code> \u2013 FastAPI demo exposing <code>/metrics</code> using <code>prometheus_client.generate_latest()</code> - <code>prometheus</code> \u2013 scrapes <code>app:8000/metrics</code> - <code>grafana</code> \u2013 UI at <code>http://localhost:3000</code> (admin/admin by default)</p> <pre><code>docker compose -f deploy/compose/metrics/docker-compose.yml up --build\nopen http://localhost:8000/docs\nopen http://localhost:9090\nopen http://localhost:3000\n</code></pre> <p>Prometheus best practices: prefer Histograms for latency, choose buckets thoughtfully; when changing buckets, use a new metric name and keep the old during the transition to preserve history.</p>"},{"location":"otel_metrics/","title":"OpenTelemetry metrics","text":"<p>Install <code>rbacx[otel]</code> and wire <code>OTelMetrics</code>:</p> <pre><code>from rbacx import Guard\n\nfrom rbacx.metrics.otel import OpenTelemetryMetrics\nmetrics = OpenTelemetryMetrics()\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy, metrics=metrics)\n</code></pre> <p>The sink records <code>rbacx_decision_total</code> counter with attributes: <code>allowed</code>, <code>reason</code>. See OpenTelemetry metrics API spec for creating counters and histograms.</p>"},{"location":"performance/","title":"Performance","text":"<ul> <li>Keep rules specific (avoid global <code>\"*\"</code> when possible).</li> <li>Cache expensive context derivations outside of Guard calls.</li> <li>Use smart sampling to reduce log volume while keeping critical events (<code>deny</code>, <code>permit_with_obligations</code>).</li> <li>Bound log record size with <code>max_env_bytes</code>; prefer <code>as_json=True</code> for cheaper formatting.</li> <li>Prefer JSON logging to reduce formatting overhead in hot paths.</li> <li>Scale horizontally: stateless <code>Guard</code> + shared policy source (file/HTTP/S3).</li> </ul>"},{"location":"policy_authoring/","title":"Policy authoring guide","text":"<p>This guide outlines how to write clear and maintainable RBAC/ABAC/ReBAC policies.</p>"},{"location":"policy_authoring/#core-concepts","title":"Core concepts","text":"<ul> <li>RBAC \u2013 users get roles, roles carry permissions. Keep roles stable, map users to roles dynamically.</li> <li>ABAC \u2013 decisions come from evaluating attributes of subject, resource, action, and environment against rules.</li> <li>ReBAC \u2013 decisions can depend on relationships between a subject and a resource (e.g., user \u2014owner\u2192 document). Relationships are typically managed in a graph/tuple store and checked via a <code>RelationshipChecker</code> port. See Relationship conditions below for policy syntax.</li> <li>Combining algorithms \u2013 <code>deny-overrides</code>, <code>permit-overrides</code>, <code>first-applicable</code>. Choose the one that matches your risk posture.</li> </ul>"},{"location":"policy_authoring/#recommendations","title":"Recommendations","text":"<ul> <li>Start with deny-by-default (<code>deny-overrides</code>) and add explicit permits.</li> <li>Prefer simple conditions; avoid hidden coercions \u2013 types must match.</li> <li>Keep resources typed (e.g., <code>doc</code>, <code>invoice</code>) and avoid broad <code>*</code> unless required.</li> <li>Name every rule with unique id and tag high-risk rules with <code>obligations</code> (e.g., <code>mfa</code>).</li> <li>Validate policies with JSON Schema before loading and lint them in CI.</li> <li>Document ownership and review cadence for policy files.</li> <li>If strict mode is enabled, avoid relying on implicit coercions in <code>resource.id</code>, <code>resource.type</code>, <code>resource.attrs</code>, and pass aware <code>datetime</code> to time conditions. See Types.</li> <li>For ReBAC, model relationships narrowly (least privilege), prefer direct relations over deep traversals, and document how relationship data is produced and expired.</li> </ul>"},{"location":"policy_authoring/#policy-structure-jsonyaml","title":"Policy structure (JSON/YAML)","text":"<p>Common top-level keys:</p> <ul> <li><code>algorithm</code> \u2014 combining algorithm (optional; default <code>deny-overrides</code>).</li> <li><code>rules</code> \u2014 list of rule objects.</li> <li>Each rule can include:   <code>id</code>, <code>effect</code> (<code>permit</code>/<code>deny</code>), <code>actions</code>, <code>resource</code> (with <code>type</code>, optional <code>ids</code>/<code>attrs</code>), optional <code>subject</code> matchers, <code>condition</code>, <code>obligations</code>.</li> </ul>"},{"location":"policy_authoring/#conditions","title":"Conditions","text":"<p>Built-in operators include:</p> <ul> <li>Comparisons: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>Collections: <code>hasAny</code>, <code>hasAll</code>, <code>in</code>, <code>contains</code></li> <li>Time: <code>before</code>, <code>after</code>, <code>between</code></li> </ul>"},{"location":"policy_authoring/#relationship-conditions-rebac","title":"Relationship conditions (ReBAC)","text":"<p>Use <code>rel</code> to require that a subject has a specific relation to the resource. The engine consults the configured <code>RelationshipChecker</code>.</p> <p>Short form (uses the request\u2019s subject/resource):</p> <pre><code>{ \"rel\": \"owner\" }\n</code></pre> <p>Extended form:</p> <pre><code>{\n  \"rel\": {\n    \"relation\": \"editor\",\n    \"subject\": { \"type\": \"user\", \"id\": \"u123\" },   // optional override\n    \"resource\": { \"type\": \"doc\", \"id\": \"d42\" },    // optional override\n    \"ctx\": { \"reason\": \"delegation\" }              // optional per-check context\n  }\n}\n</code></pre> <p>Semantics:</p> <ul> <li>If <code>subject</code>/<code>resource</code> are omitted, the engine uses the inputs of the access check.</li> <li><code>ctx</code> (if provided) is merged into a dedicated ReBAC context for the checker.</li> <li>Fail-closed: if no <code>RelationshipChecker</code> is configured, <code>rel</code> evaluates to <code>false</code>.</li> <li>Combine with ABAC/RBAC conditions as usual (e.g., require a role and a relationship).</li> </ul> <p>Tip: In tuple/graph systems (e.g., SpiceDB, OpenFGA), relationships are expressed as subject\u2013relation\u2013object and can be modeled for users, groups, and object hierarchies.</p>"},{"location":"policy_authoring/#examples","title":"Examples","text":""},{"location":"policy_authoring/#permit-with-mfa-requirement","title":"Permit with MFA requirement","text":"<pre><code>{\n  \"rules\": [\n    {\n      \"id\": \"doc_read\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"obligations\": [ { \"type\": \"require_mfa\" } ]\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_authoring/#rebac-owner-may-edit-their-document","title":"ReBAC: owner may edit their document","text":"<pre><code>{\n  \"rules\": [\n    {\n      \"id\": \"doc_edit_owner\",\n      \"effect\": \"permit\",\n      \"actions\": [\"edit\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"rel\": \"owner\" }\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_authoring/#combine-abac-and-rebac-editors-in-same-tenant-during-office-hours","title":"Combine ABAC and ReBAC: editors in same tenant, during office hours","text":"<pre><code>algorithm: deny-overrides\nrules:\n  - id: doc_edit_editor_tenant_hours\n    effect: permit\n    actions: [edit]\n    resource: { type: doc, attrs: { tenant_id: \"${context.tenant_id}\" } }\n    condition:\n      all:\n        - rel: editor\n        - between:\n            attr: context.now\n            start: \"09:00\"\n            end: \"18:00\"\n</code></pre>"},{"location":"policy_authoring/#first-applicable","title":"First-applicable","text":"<p>Stops on the first matched permit/deny, useful for ordered policies.</p>"},{"location":"policy_authoring/#yaml-example","title":"YAML example","text":"<pre><code>algorithm: first-applicable\nrules:\n  - id: p1\n    effect: permit\n    actions: [read]\n    resource: { type: doc }\n    condition:\n      hasAny:\n        - attr: subject.roles\n        - [user, viewer]\n  - id: d1\n    effect: deny\n    actions: [delete]\n    resource: { type: doc }\n</code></pre>"},{"location":"policy_authoring/#testing-validation-tips","title":"Testing &amp; validation tips","text":"<ul> <li>Write table-driven tests per rule (inputs \u2192 expected decision).</li> <li>Include negative tests for missing relations (ReBAC) and type mismatches (ABAC).</li> <li>In CI, run the linter and schema validation before deploying policies.</li> <li>For ReBAC backends, seed fixture tuples/relationships for deterministic tests.</li> </ul>"},{"location":"policy_catalog/","title":"Policy Catalog (RBAC &amp; ABAC patterns)","text":""},{"location":"policy_catalog/#tenant-isolation-resourceownertenant","title":"Tenant isolation (resource.owner/tenant)","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"tenant_read\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ { \"attr\": \"subject.tenant\" }, { \"attr\": \"resource.tenant\" } ] }\n    },\n    {\n      \"id\": \"tenant_write\",\n      \"effect\": \"permit\",\n      \"actions\": [\"write\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ { \"attr\": \"subject.tenant\" }, { \"attr\": \"resource.tenant\" } ] }\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#owner-only","title":"Owner-only","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"owner\",\n      \"effect\": \"permit\",\n      \"actions\": [\"*\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ { \"attr\": \"subject.id\" }, { \"attr\": \"resource.owner\" } ] }\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#clearance-classification-numbers","title":"Clearance &gt;= classification (numbers)","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"clearance\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"record\" },\n      \"condition\": { \"&gt;=\": [ { \"attr\": \"subject.clearance\" }, { \"attr\": \"resource.classification\" } ] }\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#time-window-business-hours-mfa-obligation","title":"Time window (business hours) + MFA obligation","text":"<pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"work_hours\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"and\": [\n        { \"&gt;=\": [ { \"attr\": \"context.hour\" }, 8 ] },\n        { \"&lt;\":  [ { \"attr\": \"context.hour\" }, 18 ] }\n      ] }\n    },\n    {\n      \"id\": \"mfa\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ { \"attr\": \"context.mfa\" }, true ] },\n      \"obligations\": [ { \"type\": \"require_mfa\" } ]\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#segmented-deletes-id-allow-list","title":"Segmented deletes (id allow-list)","text":"<pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\": [\n    {\"id\":\"delete_whitelist\",\"effect\":\"permit\",\"actions\":[\"delete\"],\"resource\":{\"type\":\"doc\",\"id\":\"A\"}},\n    {\"id\":\"no_delete_others\",\"effect\":\"deny\",\"actions\":[\"delete\"],\"resource\":{\"type\":\"doc\"}}\n  ]\n}\n</code></pre>"},{"location":"policy_loading/","title":"Policy loading (hot reload)","text":"<p>RBACX supports hot-reloading policies from external sources via a production-grade reloader.</p> <ul> <li>A policy source implements the <code>PolicySource</code> protocol (sync or async):   <code>load() -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]</code> and <code>etag() -&gt; Optional[str] | Awaitable[Optional[str]]</code>.</li> <li>The <code>HotReloader</code> watches a source: when its ETag changes, it loads the new policy and applies it to a running <code>Guard</code>. (If <code>etag()</code> returns <code>None</code>, the reloader will attempt a load and let the source decide change detection.) ETag is a standard content version identifier in HTTP and storage systems.</li> </ul>"},{"location":"policy_loading/#when-to-use","title":"When to use","text":"<ul> <li>You want changes to JSON or dict policies to be picked up without restarting your application.</li> <li>You use file/HTTP/S3 (or any custom) policy storage and want automatic or manual checks for updates.</li> <li>You want resilient reloads with exponential backoff + jitter after errors to avoid thundering herds.</li> </ul>"},{"location":"policy_loading/#quick-examples","title":"Quick examples","text":""},{"location":"policy_loading/#1-safe-startup-recommended","title":"1) Safe startup (recommended)","text":"<p>Ensures a valid policy is loaded at boot, then enables background polling.</p> <pre><code>from rbacx import Guard\nfrom rbacx.store import FilePolicySource\nfrom rbacx import HotReloader\n\nguard = Guard(policy={})\nsource = FilePolicySource(\"policy.json\")\n\nreloader = HotReloader(guard, source, initial_load=True, poll_interval=2.0)\n\n# Synchronously load whatever is in policy.json right now\nreloader.check_and_reload()        # returns True on first load\n\n# Then keep watching for changes in the background\nreloader.start()\n# ...\nreloader.stop()\n</code></pre>"},{"location":"policy_loading/#2-legacy-behavior-no-initial-load","title":"2) Legacy behavior (no initial load)","text":"<p>First check is a NO-OP unless the policy changes (backwards-compatible default).</p> <pre><code>reloader = HotReloader(guard, source, initial_load=False)\nreloader.check_and_reload()        # likely False until ETag changes\n</code></pre>"},{"location":"policy_loading/#3-force-a-one-time-load-ignore-etag","title":"3) Force a one-time load (ignore ETag)","text":"<p>Useful for bootstrap/migrations.</p> <pre><code>reloader = HotReloader(guard, source)\nreloader.check_and_reload(force=True)\n</code></pre>"},{"location":"policy_loading/#4-force-initial-load-via-start","title":"4) Force initial load via <code>start()</code>","text":"<p>Performs a synchronous load before the thread starts.</p> <pre><code>reloader = HotReloader(guard, source, initial_load=False)\nreloader.start(initial_load=True, force_initial=True)\n</code></pre> <p>Steps: 1) Start with an initial or empty policy 2) Choose source (Local filesystem in examples) 3) Create the reloader (optionally enable <code>initial_load</code>) 4) Optional: force a one-time check at startup 5) Optional: run background polling 6) Your app runs between <code>start()</code> and <code>stop()</code></p>"},{"location":"policy_loading/#hotreloader-api","title":"HotReloader API","text":"<pre><code>from rbacx import HotReloader\n</code></pre>"},{"location":"policy_loading/#constructor-parameters","title":"Constructor parameters","text":"Parameter Description <code>guard</code> The <code>rbacx.core.engine.Guard</code> instance to update. <code>source</code> Any <code>PolicySource</code> (File, HTTP, S3, custom, \u2026). <code>initial_load: bool = False</code> If <code>True</code>, do not prime the ETag so the first <code>check_and_reload()</code> will load the current policy. If <code>False</code> (default), the first check is a NO-OP unless the ETag changed (legacy behavior). <code>poll_interval: float = 5.0</code> Default polling interval (seconds) used by <code>start()</code>."},{"location":"policy_loading/#methods","title":"Methods","text":"<ul> <li> <p><code>check_and_reload(*, force: bool = False) -&gt; bool</code>   Synchronously checks the source\u2019s ETag; if changed, loads and applies the policy.   If <code>force=True</code>, loads and applies regardless of ETag. Returns <code>True</code> if a reload occurred.</p> </li> <li> <p><code>start(interval: float | None = None, *, initial_load: bool | None = None, force_initial: bool = False) -&gt; None</code>   Starts background polling.</p> </li> <li><code>interval</code> overrides the constructor\u2019s <code>poll_interval</code>.</li> <li><code>initial_load</code> overrides the constructor\u2019s flag just for this start.</li> <li> <p>If <code>initial_load</code> is truthy and <code>force_initial=True</code>, performs a synchronous load before starting the thread (ETag ignored for that initial load).</p> </li> <li> <p><code>stop(timeout: float | None = None) -&gt; None</code>   Stops background polling; optionally waits up to <code>timeout</code> seconds for the current check.</p> </li> </ul>"},{"location":"policy_loading/#diagnostics-properties","title":"Diagnostics / properties","text":"<ul> <li><code>last_etag</code> \u2014 most recently seen ETag from the source.</li> <li><code>last_reload_at</code> \u2014 timestamp of the last successful reload.</li> <li><code>last_error</code> \u2014 the last exception encountered (if any).</li> <li><code>suppressed_until</code> \u2014 time until which further attempts are delayed after errors (exponential backoff with jitter).</li> </ul>"},{"location":"policy_loading/#typical-reload-cycle","title":"Typical reload cycle","text":"<ol> <li>Ask the <code>PolicySource</code> for its current ETag.</li> <li>If the ETag is new (or <code>etag()</code> is <code>None</code>), call <code>load()</code> to fetch the policy.</li> <li>Validate (if the source performs schema checks).</li> <li>Apply the policy to <code>guard</code> only after a successful load.</li> <li>On errors (parse, network, permissions), keep the previous working policy, log the error, and schedule the next attempt using exponential backoff with jitter.</li> </ol>"},{"location":"policy_loading/#integration-with-web-frameworks","title":"Integration with web frameworks","text":""},{"location":"policy_loading/#asgi-middleware-on-request-checks","title":"ASGI middleware &amp; on-request checks","text":"<p>Use <code>HotReloader</code> with your middleware to check for changes before handling requests, or rely solely on background polling.</p> <pre><code>from rbacx.adapters.asgi import RbacxMiddleware\nfrom rbacx import Guard\nfrom rbacx.store import FilePolicySource\nfrom rbacx import HotReloader\nfrom litestar import Litestar, get\nfrom litestar.middleware import DefineMiddleware\n\nguard = Guard(policy={})\nreloader = HotReloader(guard, FilePolicySource(\"policy.json\"), initial_load=True, poll_interval=2.0)\nreloader.check_and_reload()  # ensure policy is present at startup\n\n@get(\"/secure\")\ndef secure() -&gt; dict:\n    # guard used automatically via middleware or dependency\n    return {\"ok\": True}\n\napp = Litestar(\n    route_handlers=[secure],\n    middleware=[DefineMiddleware(RbacxMiddleware, guard=guard, policy_reloader=reloader)],\n)\n</code></pre> <p>If you need ultra-low detection latency, call <code>reloader.check_and_reload()</code> at the beginning of request handling (cheap ETag check), or keep background polling short.</p>"},{"location":"policy_loading/#supported-policysource-types","title":"Supported <code>PolicySource</code> types","text":"<p>Out of the box, RBACX provides:</p> <ul> <li>FilePolicySource \u2014 local JSON file or dict snapshot.</li> <li>HTTPPolicySource \u2014 HTTP/HTTPS endpoint (ideal with ETag or Last-Modified validators).</li> <li>S3PolicySource \u2014 Amazon S3 objects with ETag-based change detection.</li> </ul> <p>Any custom source that implements <code>load()</code> and <code>etag()</code> is supported.</p>"},{"location":"policy_loading/#operational-guidance","title":"Operational guidance","text":"<ul> <li>Atomic writes (file sources): write to a temp file and <code>rename</code> to avoid readers seeing partial content.</li> <li>Backoff &amp; jitter: on repeated failures, use exponential backoff with jitter; this avoids synchronized retries and thundering herds. RBACX\u2019s reloader applies jitter by default.</li> <li>Observability: export metrics/counters for reload successes/failures and <code>last_reload_at</code>.</li> <li>Fail-safe policy: keep the last known good policy if a new load fails.</li> <li>Security defaults: default-deny policies are recommended until the first valid policy is loaded.</li> </ul>"},{"location":"policy_loading/#sync-vs-async-usage","title":"Sync vs Async usage","text":"<p><code>HotReloader</code> exposes both a synchronous and an asynchronous API:</p> <ul> <li><code>check_and_reload(...)</code> \u2014 sync wrapper over the async core. Safe to call in synchronous apps (Flask/CLI) and even inside a running event loop; the reloader will delegate work to a helper thread.</li> <li><code>check_and_reload_async(...)</code> \u2014 async-native method for ASGI/async tasks.</li> </ul> <p>Examples:</p> <p>Sync (Flask/CLI/Celery)</p> <pre><code>reloader = HotReloader(guard, source)\nchanged = reloader.check_and_reload()\n</code></pre> <p>Async (FastAPI background task / asyncio)</p> <pre><code>reloader = HotReloader(guard, source)\nchanged = await reloader.check_and_reload_async()\n</code></pre>"},{"location":"policy_loading/#deprecated-api","title":"Deprecated API","text":"<ul> <li><code>ReloadingPolicyManager</code> is deprecated and kept only for compatibility. Constructing it emits a <code>DeprecationWarning</code> and a log warning; it delegates to <code>HotReloader</code> with legacy semantics (<code>initial_load=False</code>). Please migrate to <code>HotReloader</code>.</li> <li><code>PolicyManager</code> from <code>rbacx.store.manager</code> is deprecated; use <code>HotReloader</code> (plus a <code>PolicySource</code> such as <code>FilePolicySource</code>) instead.</li> </ul>"},{"location":"policy_loading/#changelog-excerpt","title":"Changelog (excerpt)","text":"<ul> <li><code>HotReloader(..., initial_load: bool = False)</code> \u2014 new flag to control startup behavior.</li> <li><code>check_and_reload(force: bool = False)</code> \u2014 new <code>force</code> parameter to bypass ETag.</li> <li><code>start(..., initial_load: bool | None = None, force_initial: bool = False)</code> \u2014 optional synchronous load before the polling thread starts.</li> <li><code>ReloadingPolicyManager</code> and <code>rbacx.store.manager.PolicyManager</code> \u2014 deprecated; use <code>HotReloader</code>.</li> </ul>"},{"location":"policy_stores/","title":"Policy stores","text":"<p>Policy sources implement a single protocol:</p> <pre><code>from typing import Any, Dict, Optional, Protocol, Awaitable\n\nclass PolicySource(Protocol):\n    def load(self) -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]: ...\n    def etag(self) -&gt; Optional[str] | Awaitable[Optional[str]]: ...\n</code></pre> <p>Out of the box, three stores are available: File, HTTP, S3.</p>"},{"location":"policy_stores/#filepolicysource-local-file","title":"FilePolicySource (local file)","text":"<p>Module: <code>rbacx.store.file_store</code> (also re-exported from <code>rbacx.store</code>).</p>"},{"location":"policy_stores/#import-basic-usage","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store import FilePolicySource\n\nsource = FilePolicySource(\"policy.json\")  # path to a JSON file\ndoc = source.load()                       # policy as a dict\ntag = source.etag()                       # string or None\n</code></pre>"},{"location":"policy_stores/#behavior","title":"Behavior","text":"<ul> <li>Loads JSON from a local file.</li> <li><code>etag()</code> reflects the file content (suitable for change detection).</li> <li>If validation is enabled, it performs a schema check via <code>rbacx.dsl.validate</code>.</li> </ul>"},{"location":"policy_stores/#constructor-options-core","title":"Constructor options (core)","text":"<ul> <li><code>validate_schema: bool = False</code> \u2014 enable schema validation on <code>load()</code>.</li> <li><code>include_mtime_in_etag: bool</code> - if needed \"touch\" changes detected (default <code>False</code>).</li> </ul>"},{"location":"policy_stores/#safe-write-utility","title":"Safe write utility","text":"<pre><code>from rbacx.store import atomic_write\n\natomic_write(\"policy.json\", data='{\"rules\": []}', encoding=\"utf-8\")\n</code></pre>"},{"location":"policy_stores/#httppolicysource-httphttps","title":"HTTPPolicySource (HTTP/HTTPS)","text":"<p>Module: <code>rbacx.store.http_store</code>. Extra dependency: <code>pip install \"rbacx[http]\"</code>.</p>"},{"location":"policy_stores/#import-basic-usage_1","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store.http_store import HTTPPolicySource  # also re-exported from `rbacx.store`.\n\nsource = HTTPPolicySource(\"https://example.com/rbac/policy.json\")\ndoc = source.load()   # dict; if server returns 304 Not Modified \u2014 returns {}\ntag = source.etag()   # last ETag (if provided by the server)\n</code></pre>"},{"location":"policy_stores/#behavior_1","title":"Behavior","text":"<ul> <li>Issues a GET request and, if a previous ETag is known, sends <code>If-None-Match</code>.</li> <li>On <code>304 Not Modified</code>, returns empty dict <code>{}</code> \u2014 a signal that applying can be skipped.</li> <li>If schema validation is enabled, the loaded policy is validated against the built-in schema before being returned.</li> </ul>"},{"location":"policy_stores/#constructor-options-core_1","title":"Constructor options (core)","text":"<ul> <li><code>headers: dict[str, str] | None = None</code> \u2014 additional HTTP headers.</li> <li><code>validate_schema: bool = False</code> \u2014 when <code>True</code>, the store validates the parsed policy during <code>load()</code>. The default is <code>False</code> to preserve backward-compatible behavior and avoid adding a validation dependency unless explicitly requested.</li> </ul>"},{"location":"policy_stores/#s3policysource","title":"S3PolicySource","text":"<p>Module: <code>rbacx.store.s3_store</code> (also re-exported from <code>rbacx.store</code>). Requires: <code>boto3</code> (and optionally <code>botocore</code> for advanced client tuning).</p>"},{"location":"policy_stores/#import-basic-usage_2","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store import S3PolicySource\n\nsource = S3PolicySource(\"s3://my-bucket/policies/rbac.json\")\ndoc = source.load()   # JSON document from S3 as a dict\ntag = source.etag()   # string or None (depending on the strategy)\n</code></pre>"},{"location":"policy_stores/#change-detection-strategies","title":"Change-detection strategies","text":"<p>The <code>change_detector</code> parameter selects the source of the \"change tag\":</p> <ul> <li><code>\"etag\"</code> (default) \u2014 uses ETag from <code>HeadObject</code>.</li> <li><code>\"version_id\"</code> \u2014 uses <code>VersionId</code> (bucket versioning must be enabled).</li> <li><code>\"checksum\"</code> \u2014 uses <code>GetObjectAttributes(..., ObjectAttributes=['Checksum'])</code> if object checksums are enabled.</li> </ul> <p>If a strategy is unavailable for a particular bucket/object, use <code>\"etag\"</code> (the most compatible option).</p>"},{"location":"policy_stores/#options-core","title":"Options (core)","text":"<ul> <li><code>validate_schema: bool = False</code> \u2014 validate the policy against the schema on <code>load()</code>.</li> </ul> <p>Network/client parameters:</p> <ul> <li>You can pass a prepared <code>boto3.Session</code>.</li> <li>Timeouts/retries can be tuned via <code>botocore.config.Config</code>.</li> <li>Additional client parameters are accepted (e.g., <code>endpoint_url</code>, <code>region_name</code>).</li> </ul> <p>(Argument names match the <code>S3PolicySource</code> constructor; use the simple form from the example if you don't need advanced tuning.)</p>"},{"location":"policy_stores/#using-with-hotreloader","title":"Using with HotReloader","text":"<p>Any store can be connected to <code>HotReloader</code>:</p> <pre><code>from rbacx import Guard\nfrom rbacx import HotReloader\nfrom rbacx.store import FilePolicySource, S3PolicySource\nfrom rbacx.store.http_store import HTTPPolicySource\n\nguard = Guard(policy={})\n\n# Local file\nfile_src = FilePolicySource(\"policy.json\")\nHotReloader(guard, file_src, poll_interval=2.0).start()\n\n# HTTP\nhttp_src = HTTPPolicySource(\"https://example.com/rbac/policy.json\")\nHotReloader(guard, http_src, poll_interval=5.0).start()\n\n# S3\ns3_src = S3PolicySource(\"s3://my-bucket/policies/rbac.json\")\nHotReloader(guard, s3_src, poll_interval=5.0).start()\n</code></pre> <p>It is recommended to begin with an explicit <code>check_and_reload()</code> when the process starts, and then either enable background polling with <code>start()</code> or call <code>check_and_reload()</code> at request boundaries (see <code>RbacxMiddleware</code>).</p>"},{"location":"prometheus/","title":"Prometheus metrics","text":"<p>Install the extra and wire the sink:</p> <pre><code>pip install \"rbacx[metrics]\"\n# or: pip install prometheus-client\n</code></pre> <pre><code>from rbacx.core.engine import Guard\nfrom rbacx.metrics.prometheus import PrometheusMetrics\n\nmetrics = PrometheusMetrics()\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy, metrics=metrics)\n</code></pre> <p>Expose the metrics endpoint (HTTP exporter from <code>prometheus_client</code>):</p> <pre><code>from prometheus_client import start_http_server\nstart_http_server(8000)  # scrape http://localhost:8000/\n</code></pre>"},{"location":"prometheus/#what-is-exported","title":"What is exported","text":"<ul> <li> <p>Counter <code>rbacx_decisions_total{decision}</code> \u2014 increments by 1 for every decision.   Label <code>decision</code> has values like <code>permit</code> or <code>deny</code>.</p> </li> <li> <p>Histogram <code>rbacx_decision_seconds</code> \u2014 decision evaluation duration in seconds.   No labels by default.</p> </li> </ul> <p>Notes - Metric names and units follow Prometheus conventions (e.g., <code>_total</code> for counters and <code>_seconds</code> for durations). - If <code>prometheus_client</code> is not installed, the sink safely no-ops.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This page shows how to install RBACX and its optional extras.</p> <p>RBACX keeps the core lightweight and avoids pulling heavy dependencies by default. This helps keep it framework\u2011agnostic and reduces conflicts in real projects. If you need integrations or helpers, install extras selectively.</p>"},{"location":"quickstart/#install","title":"Install","text":"<p>Minimal install:</p> <pre><code>pip install rbacx\n</code></pre>"},{"location":"quickstart/#optional-features-extras","title":"Optional features (extras)","text":"Extra Enables Install command <code>adapters-fastapi</code> FastAPI / Starlette adapters <code>pip install rbacx[adapters-fastapi]</code> <code>adapters-flask</code> Flask adapters <code>pip install rbacx[adapters-flask]</code> <code>adapters-drf</code> Django + DRF adapters <code>pip install rbacx[adapters-drf]</code> <code>adapters-litestar</code> Litestar adapters <code>pip install rbacx[adapters-litestar]</code> <code>metrics</code> Prometheus client metrics <code>pip install rbacx[metrics]</code> <code>otel</code> OpenTelemetry API/SDK helpers <code>pip install rbacx[otel]</code> <code>http</code> HTTP policy source (requests) <code>pip install rbacx[http]</code> <code>s3</code> S3 policy source (boto3) <code>pip install rbacx[s3]</code> <code>dates</code> Time operators support (python\u2011dateutil) <code>pip install rbacx[dates]</code> <code>yaml</code> YAML policies support <code>pip install rbacx[yaml]</code> <p>You can combine extras:</p> <pre><code>pip install 'rbacx[adapters-fastapi,metrics,otel]'\n</code></pre> <p>Why a separate YAML extra? YAML is optional. If you want to author policies in YAML, install <code>rbacx[yaml]</code>. YAML\u2019s official media type is <code>application/yaml</code> (see RFC 9512). For security, we parse YAML with <code>yaml.safe_load</code>.</p>"},{"location":"quickstart/#define-a-policy-json-or-yaml","title":"Define a policy (JSON or YAML)","text":"<p>Both JSON and YAML are supported. They\u2019re parsed into a <code>dict</code> and validated against the same JSON Schema.</p> <p>JSON:</p> <pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\": [\n    {\"id\": \"p1\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}},\n    {\"id\": \"d1\", \"effect\": \"deny\",   \"actions\": [\"delete\"], \"resource\": {\"type\": \"doc\"}}\n  ]\n}\n</code></pre> <p>YAML:</p> <pre><code>algorithm: permit-overrides\nrules:\n  - id: p1\n    effect: permit\n    actions: [read]\n    resource: { type: doc }\n  - id: d1\n    effect: deny\n    actions: [delete]\n    resource: { type: doc }\n</code></pre>"},{"location":"quickstart/#load-a-policy","title":"Load a policy","text":"<p>You can load policies from files, HTTP, or S3 or create your policy source.</p> <pre><code>from rbacx import Guard\nfrom rbacx.store.file_store import FilePolicySource\nfrom rbacx.store.http_store import HTTPPolicySource\nfrom rbacx.store.s3_store import S3PolicySource\n\nguard = Guard(policy=FilePolicySource(\"examples/policies/ok_policy.json\").load())\n# guard = Guard(policy=FilePolicySource(\"examples/policies/ok_policy.yaml\").load())  # requires rbacx[yaml]\n\n# HTTP: YAML detected by Content-Type (application/yaml) or URL suffix .yaml/.yml\n# guard = Guard(policy=HTTPPolicySource(\"https://example.com/policy.yaml\").load())\n\n# S3: YAML detected by key suffix .yaml/.yml\n# guard = Guard(policy=S3PolicySource(\"s3://my-bucket/policy.yaml\").load())\n</code></pre>"},{"location":"quickstart/#cli","title":"CLI","text":"<p>Lint a policy file (JSON or YAML):</p> <pre><code>rbacx lint --policy examples/policies/ok_policy.json\nrbacx lint --policy examples/policies/ok_policy.yaml\nrbacx lint --policy examples/policies/bad_policy.json\nrbacx lint --policy examples/policies/bad_policy.yaml\n</code></pre> <p>The CLI prints JSON diagnostics. A non-empty list means warnings/errors were found.</p> <p>Need more? See the full docs site for adapters, middleware, metrics, and advanced configuration.</p>"},{"location":"quickstart/#rebac-local-in-60-seconds","title":"ReBAC (local) in 60 seconds","text":"<pre><code>from rbacx.core.engine import Guard\nfrom rbacx.rebac.local import LocalRelationshipChecker, InMemoryRelationshipStore, This\n\n# 1) Build a tiny graph in memory\nstore = InMemoryRelationshipStore()\nstore.add(\"document:doc1\", \"owner\", \"user:alice\")\n# define inheritance / computed usersets in the checker\nchecker = LocalRelationshipChecker(\n    store,\n    rules={\n        \"document\": {\"viewer\": [This(),], \"owner\": [This()]}\n    },\n)\n\n# 2) Policy uses the 'rel' condition\npolicy = {\n    \"id\": \"rebac-local-demo\",\n    \"alg\": \"deny-overrides\",\n    \"rules\": [\n        {\"id\": \"can-read\", \"when\": {\"rel\": \"viewer\"}, \"effect\": \"permit\",\n         \"actions\": [\"document.read\"], \"resources\": [{\"type\": \"document\"}]}\n    ],\n}\n\nguard = Guard(policy, relationship_checker=checker)\n</code></pre>"},{"location":"reasons/","title":"Decision reasons","text":"Reason Meaning <code>matched</code> A permit rule matched <code>explicit_deny</code> A deny rule matched <code>condition_mismatch</code> Condition evaluated to False <code>condition_type_mismatch</code> Incompatible types in a condition <code>resource_mismatch</code> Resource type/id/attrs didn't match <code>action_mismatch</code> Action not in rule's action list <code>no_match</code> No rule matched <code>obligation_failed</code> Obligations required by a permit rule were not met or failed verification (e.g., MFA) <p>Operators include: <code>hasAll</code>, <code>hasAny</code>, <code>before/after/between</code>, plus standard comparisons.</p>"},{"location":"roles/","title":"Role hierarchy","text":"<p>Use <code>StaticRoleResolver</code> to expand roles with inheritance:</p> <pre><code>from rbacx.core.roles import StaticRoleResolver\nresolver = StaticRoleResolver({\"admin\":[\"manager\"], \"manager\":[\"employee\"]})\nexpanded = resolver.expand([\"admin\"])  # ['admin','employee','manager']\n</code></pre> <p>Wire into the <code>Guard</code>:</p> <pre><code>from rbacx import Guard\n\npolicy = {...}  # define yours here\nresolver = ...  # use resolver from above\n\nguard = Guard(policy, role_resolver=resolver)\n</code></pre> <p>The RBAC standard (ANSI/INCITS 359-2004) includes role hierarchies.</p>"},{"location":"security/","title":"Security","text":"<ul> <li>Validate policies (JSON Schema 2020-12) before applying.</li> <li>Avoid logging sensitive data; apply masking obligations to payloads. When using <code>DecisionLogger</code>, prefer <code>use_default_redactions=True</code> (if you don't pass explicit <code>redactions</code>) and consider <code>max_env_bytes</code> to bound payload size.</li> <li>Reload policies atomically (HotReloader already re-computes etag).</li> <li>Consider step-up auth challenges (e.g., MFA) for high-risk actions.</li> </ul> <p>Note (caching): when using shared/external caches, avoid putting sensitive data into keys/metadata and choose a backend that fits your security requirements. The default in-memory cache is per-process/per-Guard.</p>"},{"location":"strategies/","title":"Authorization Strategies: RBAC, ABAC, ReBAC","text":"<p>There are the three strategies supported by RBACX.</p>"},{"location":"strategies/#rbac-role-based-access-control","title":"RBAC (Role-Based Access Control)","text":"<ul> <li>Concept. Users are assigned roles; roles grant permissions.</li> <li>Use when. Stable, bounded sets of duties (e.g., back-office roles).</li> </ul>"},{"location":"strategies/#abac-attribute-based-access-control","title":"ABAC (Attribute-Based Access Control)","text":"<ul> <li>Concept. Policies evaluate attributes of subject, resource, action, and environment.</li> <li>Use when. Dynamic, fine-grained rules (ownership, time, location, device posture).</li> </ul>"},{"location":"strategies/#rebac-relationship-based-access-control","title":"ReBAC (Relationship-Based Access Control)","text":"<ul> <li>Concept. Permissions derive from relationships between subjects and resources (Zanzibar-style).</li> <li>Use when. Collaboration graphs, sharing models, delegation, inheritance chains.</li> <li>See <code>docs/rebac/*</code> for detailed guides.</li> </ul>"},{"location":"time_operators/","title":"Time operators","text":"<p>See also: Types for lax vs. strict type semantics of time operators.</p> <p>Operators: <code>before</code>, <code>after</code>, <code>between</code> using ISO-8601 strings (e.g., <code>2025-09-07T10:00:00Z</code>).</p> <ul> <li>Parser prefers <code>datetime.fromisoformat</code>, normalizing <code>Z</code> to <code>+00:00</code>.</li> <li>Falls back to <code>dateutil.isoparse</code> if <code>rbacx[dates]</code> installed.</li> </ul> <p>Examples: <pre><code>{\"before\": [ {\"attr\":\"context.now\"}, \"2025-12-31T23:59:59Z\" ]}\n{\"between\": [ {\"attr\":\"context.now\"}, [\"2025-01-01T00:00:00Z\",\"2025-12-31T23:59:59Z\"] ]}\n</code></pre></p>"},{"location":"try_examples/","title":"Running the examples (Django, DRF, FastAPI, Flask, Litestar)","text":"<p>This guide shows how to run all demo apps under <code>examples/</code>, exactly as implemented in the sources.</p> <ul> <li><code>examples/django_demo</code> \u2014 plain Django</li> <li><code>examples/drf_demo</code> \u2014 Django REST Framework</li> <li><code>examples/fastapi_demo</code> \u2014 FastAPI</li> <li><code>examples/flask_demo</code> \u2014 Flask</li> <li><code>examples/litestar_demo</code> \u2014 Litestar</li> </ul>"},{"location":"try_examples/#install-from-pypi-extras","title":"Install from PyPI (extras)","text":"<p>Install only what you need via extras from PyPI (no editable install):</p> <pre><code># choose one or more:\npip install rbacx[adapters-drf]\npip install rbacx[adapters-fastapi]\npip install rbacx[adapters-flask]\npip install rbacx[adapters-litestar]\n# or everything used by the examples:\npip install rbacx[examples]\n</code></pre> <p>Depending on your shell you may need quotes: <code>pip install \"rbacx[adapters-drf]\"</code>.</p>"},{"location":"try_examples/#django-examplesdjango_demo","title":"Django (<code>examples/django_demo</code>)","text":"<pre><code>python examples/django_demo/manage.py migrate\npython examples/django_demo/manage.py runserver 127.0.0.1:8000\n# Test:\ncurl -i http://127.0.0.1:8000/health\ncurl -i http://127.0.0.1:8000/doc\n</code></pre> <p>Endpoints - <code>GET /health</code> \u2192 <code>{\"ok\": true}</code> - <code>GET /doc</code> \u2192 JSON decision result:   - Allowed: <code>{ \"allowed\": true, \"docs\": [\"doc-1\", \"doc-2\"] }</code>   - Denied: <code>{ \"allowed\": false, \"reason\": \"...\" }</code> (HTTP 403)</p> <p>The demo uses a tiny in-repo guard (see <code>rbacx_demo/rbacx_factory.py</code>). The <code>docs</code> view normalizes a decision-like object and returns JSON accordingly.</p>"},{"location":"try_examples/#django-rest-framework-examplesdrf_demo","title":"Django REST Framework (<code>examples/drf_demo</code>)","text":"<pre><code>python examples/drf_demo/manage.py migrate\npython examples/drf_demo/manage.py runserver 127.0.0.1:8001\n# Test:\ncurl -i http://127.0.0.1:8001/docs\n</code></pre> <p>Endpoint - <code>GET /docs</code> \u2192 <code>{ \"ok\": true }</code> on success</p> <p>Access control is enforced with <code>rbacx.adapters.drf.make_permission(guard, build_env)</code>, see <code>docsapp/views.py</code>. The example policy in <code>docsapp/policy.json</code> permits <code>read</code> on resources of type <code>\"doc\"</code>.</p>"},{"location":"try_examples/#fastapi-examplesfastapi_demo","title":"FastAPI (<code>examples/fastapi_demo</code>)","text":"<pre><code>uvicorn examples.fastapi_demo.app:app --reload --port 8002\n# Test:\ncurl -i http://127.0.0.1:8002/ping\ncurl -i http://127.0.0.1:8002/doc\n</code></pre> <p>Endpoints - <code>GET /ping</code> \u2192 <code>{\"pong\": true}</code> - <code>GET /doc</code>  \u2192 <code>{\"ok\": true}</code> on success</p> <p>The dependency <code>require_access(guard, build_env, add_headers=True)</code> checks access before the handler. <code>build_env</code> reads <code>X-User</code> (optional) and constructs: <code>Subject(id, roles=[\"user\"])</code>, <code>Action(\"read\")</code>, <code>Resource(type=\"doc\")</code>, <code>Context()</code>.</p>"},{"location":"try_examples/#flask-examplesflask_demo","title":"Flask (<code>examples/flask_demo</code>)","text":"<pre><code>flask --app examples/flask_demo/app.py run --port 8003\n# Test:\ncurl -i http://127.0.0.1:8003/ping\ncurl -i http://127.0.0.1:8003/doc\n</code></pre> <p>Endpoints - <code>GET /ping</code> \u2192 <code>{\"pong\": true}</code> - <code>GET /doc</code> \u2192 protected by <code>@require_access(...)</code></p> <p><code>build_env</code> also reads the optional <code>X-User</code> header and sets roles to <code>[\"user\"]</code>.</p>"},{"location":"try_examples/#litestar-exampleslitestar_demo","title":"Litestar (<code>examples/litestar_demo</code>)","text":"<pre><code>uvicorn examples.litestar_demo.app:app --reload --port 8004\n# (optional structured logs)\n# uvicorn app:app --reload --port 8004 --log-config ../logging/uvicorn_logging_json.yml\n\n# Test:\ncurl -i http://127.0.0.1:8004/health\ncurl -i http://127.0.0.1:8004/docs/1\n</code></pre> <p>Endpoints - <code>GET /health</code> \u2192 <code>{\"ok\": true}</code> - <code>GET /docs/{doc_id}</code> \u2192 returns a JSON object with <code>{\"allowed\": &lt;bool&gt;}</code> computed by the guard, see <code>get_doc</code> handler. The resource type is <code>\"doc\"</code>.</p>"},{"location":"try_examples/#notes","title":"Notes","text":"<ul> <li>Authorization failures generally return 403 with a short JSON body. If your decision includes an authentication challenge (e.g., MFA required), returning 401 with an appropriate <code>WWW-Authenticate</code> or custom challenge header may be more appropriate. See Mapping Decision reasons to HTTP responses.</li> <li>Only the FastAPI and Flask demos read <code>X-User</code>; DRF uses <code>request.user</code>; Django demo uses a hard-coded demo subject with the <code>demo_user</code> role.</li> </ul>"},{"location":"try_examples/#yaml-policies","title":"YAML policies","text":"<p>You can also try YAML policies:</p> <pre><code>rbacx lint --policy examples/policies/ok_policy.yaml\nrbacx lint --policy examples/policies/bad_policy.yaml\n</code></pre>"},{"location":"types/","title":"Types","text":"<p>Type semantics used during policy evaluation.</p>"},{"location":"types/#why-types-matter","title":"Why types matter","text":"<ul> <li>Policies compare values. If a system silently converts <code>\"1\"</code> \u2194 <code>1</code> or parses dates from strings, rules may match when the author didn\u2019t intend it (or fail when an integration changes formats). This is the core \u201cimplicit type coercion\u201d problem.</li> <li>Ecosystem reality. Inputs often arrive as JSON with mixed types and date strings. Python itself has changed ISO-8601 parsing over time (e.g., <code>Z</code> support landed in 3.11), so relying on strings is convenient but version-sensitive.</li> <li>Industry patterns. Many validation/eval tools offer a lenient default and an opt-in strict path (e.g., Pydantic strict mode, JSON Schema coercion switches). The trade-off is ergonomics vs. guarantees.</li> </ul> <p>Design goal here: keep the default lax because it is practical and predictable once you know the coercion rules, absorbs common input drift (e.g., numeric <code>1</code> vs. string <code>\"1\"</code>), reduces avoidable user/integration errors, and remains backward compatible. Provide strict for teams that want exact typing and loud failures on mismatches.</p>"},{"location":"types/#modes","title":"Modes","text":"<ul> <li>Lax (default). Pragmatic, input-tolerant behavior that accepts common real-world inputs (e.g., ISO date strings, epochs) and compares certain values via stringification where historically allowed. Predictable once you know the rules; helps prevent trivial mistakes like <code>1</code> vs <code>\"1\"</code> from breaking access. Also backward compatible with existing policies.</li> <li>Strict. No implicit coercions. Enable via <code>Guard(..., strict_types=True)</code>. The engine injects <code>__strict_types__ = true</code> into the evaluation env; cache keys differ accordingly. Choose this for predictability under audit, reviewability, and stronger invariants. (Analogous to \u201cstrict mode\u201d in validators.)</li> </ul>"},{"location":"types/#resource-matching","title":"Resource matching","text":"<p>How <code>resource.type</code>, <code>resource.id</code>, and <code>resource.attrs</code> are compared:</p> Field / check Lax (default) Strict <code>resource.type</code> compared as <code>str(value)</code> exact value and type <code>resource.id</code> compared as <code>str(value)</code> exact value and type <code>resource.attrs[k] == v</code> <code>str(lhs) == str(rhs)</code> exact equality <code>lhs == rhs</code> <code>resource.attrs[k] in [...]</code> membership by stringified one-of membership by exact equality <p>Implication: in strict mode, <code>\"1\"</code> \u2260 <code>1</code>, <code>\"true\"</code> \u2260 <code>True</code>. Prefer normalizing types at ingestion rather than relying on stringification.</p>"},{"location":"types/#time-operators","title":"Time operators","text":"<p>Operators: <code>before</code>, <code>after</code>, <code>between</code>.</p> <ul> <li>Lax: accepts <code>datetime</code> (naive \u2192 coerced to UTC), ISO 8601 strings (including <code>Z</code> / <code>+00:00</code>), and epoch numbers.   Note: Python\u2019s <code>datetime.fromisoformat</code> gained broader ISO coverage (notably <code>Z</code>) in 3.11; behavior differs on older runtimes.</li> <li>Strict: accepts only timezone-aware <code>datetime</code> (<code>tzinfo</code> required). ISO strings and epoch numbers are rejected with <code>ConditionTypeError</code>; engine converts this to <code>deny</code> with <code>reason=\"condition_type_mismatch\"</code>.</li> </ul> <p>For ISO background: <code>Z</code> denotes UTC in ISO-8601.</p>"},{"location":"types/#cache-behavior","title":"Cache behavior","text":"<ul> <li>Lax: cache keys unchanged (no flag in env).</li> <li>Strict: env includes <code>__strict_types__</code>, so keys differ; results are isolated by mode.</li> </ul>"},{"location":"types/#when-to-use-which","title":"When to use which","text":"<p>Stick with lax if:</p> <ul> <li>you are onboarding legacy systems and want minimal friction;</li> <li>inputs arrive as \u201cstringly-typed\u201d JSON (IDs as strings, dates as ISO) and policies already depend on that leniency;</li> <li>you want the engine to absorb minor input drift and prevent trivial typing mistakes from breaking access.</li> </ul> <p>Prefer strict if:</p> <ul> <li>you need deterministic matches (no accidental <code>\"1\"</code> vs <code>1</code> equality);</li> <li>you review policies for compliance/security and want mismatches to fail loud;</li> <li>you rely on time comparisons across services/runtimes and want to ban string/epoch ambiguity.</li> </ul> <p>This mirrors common practice: lenient by default for ergonomics and error-reduction, strict when correctness and auditability dominate.</p>"},{"location":"types/#engine-toggle","title":"Engine toggle","text":"<pre><code>from rbacx import Guard\n\n# Lax (default)\ng1 = Guard(policy)\n\n# Strict\ng2 = Guard(policy, strict_types=True)\n</code></pre>"},{"location":"types/#authoring-guidance","title":"Authoring guidance","text":"<ul> <li>Pass aware <code>datetime</code> objects in time conditions when strict is enabled.</li> <li>Normalize <code>resource.type</code>, <code>resource.id</code>, and <code>resource.attrs</code> types at the boundary (API/deserializer).</li> <li>Keep policies mode-agnostic where possible; choose the mode at engine construction.</li> </ul>"},{"location":"types/#faq","title":"FAQ","text":"<p>Why is lax the default? It is practical, predictable given the documented coercions, reduces integration/user errors (e.g., <code>1</code> vs <code>\"1\"</code>), and preserves existing behavior. Teams can enable strict when ready.</p> <p>Does strict change decision algorithms? No. It only changes type handling (comparisons and date parsing).</p> <p>Will strict break my cache? Keys are different in strict (by design) but unchanged in lax. You can run both modes side-by-side.</p>"},{"location":"web_adapters/","title":"Web framework adapters","text":"<p>RBACX ships simple adapters for popular frameworks. for popular Python web frameworks. They all follow the same conventions:</p> <ul> <li>EnvBuilder builds <code>(Subject, Action, Resource, Context)</code> from the framework request/scope.</li> <li>Async frameworks use async adapters (<code>evaluate_async</code> under the hood).</li> <li>Sync frameworks use sync adapters (<code>evaluate_sync</code>).</li> <li>By default, do not leak reasons. If you need diagnostics, pass <code>add_headers=True</code> and read:</li> <li><code>X-RBACX-Reason</code></li> <li><code>X-RBACX-Rule</code></li> <li><code>X-RBACX-Policy</code></li> </ul> <p>See runnable apps in <code>examples/</code>.</p>"},{"location":"web_adapters/#fastapi-dependency","title":"FastAPI (dependency)","text":"<pre><code>from fastapi import FastAPI, Depends, Request\nfrom rbacx import Guard, Subject, Resource, Action, Context\nfrom rbacx.adapters.fastapi import require_access\n\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": [\n    {\"id\": \"doc_read\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}}\n]}\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    uid = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=uid, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = FastAPI()\n\n@app.get(\"/doc\", dependencies=[Depends(require_access(guard, build_env, add_headers=True))])\nasync def doc():\n    return {\"ok\": True}\n</code></pre>"},{"location":"web_adapters/#flask-decorator","title":"Flask (decorator)","text":"<pre><code>from flask import Flask, request\nfrom rbacx import Guard, Subject, Resource, Action, Context\nfrom rbacx.adapters.flask import require_access\n\n\nguard = Guard(policy)\n\ndef build_env(req):\n    # use explicit req or implicit flask.request\n    r = req or request\n    uid = r.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=uid, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = Flask(__name__)\n\n@app.get(\"/doc\")\n@require_access(guard, build_env, add_headers=True)\ndef doc():\n    return {\"ok\": True}\n</code></pre>"},{"location":"web_adapters/#starlette-decorator","title":"Starlette (decorator)","text":"<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom rbacx import Guard, Subject, Resource, Action, Context\nfrom rbacx.adapters.starlette import require_access\n\n\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    uid = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=uid, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = Starlette()\n\n@app.route(\"/doc\")\n@require_access(guard, build_env, add_headers=True)\nasync def doc(request: Request):\n    return JSONResponse({\"ok\": True})\n</code></pre>"},{"location":"web_adapters/#litestar-middleware","title":"Litestar (middleware)","text":"<pre><code>from litestar import Litestar, get\nfrom litestar.middleware import DefineMiddleware\nfrom rbacx import Guard, Subject, Resource, Action, Context\nfrom rbacx.adapters.litestar import RBACXMiddleware\n\n\nguard = Guard(policy)\n\ndef build_env(scope):\n    uid = dict(scope.get(\"headers\", [])).get(b\"x-user\", b\"anonymous\").decode(\"latin1\")\n    return Subject(id=uid, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\n@get(\"/doc\")\nasync def doc() -&gt; dict:\n    return {\"ok\": True}\n\napp = Litestar(\n    route_handlers=[doc],\n    middleware=[DefineMiddleware(RBACXMiddleware, guard=guard, build_env=build_env, add_headers=True)],\n)\n</code></pre>"},{"location":"web_adapters/#django-decorator-middleware","title":"Django (decorator + middleware)","text":"<p>Enable the middleware to inject a Guard:</p> <pre><code># settings.py\nRBACX_GUARD_FACTORY = \"rbacx_demo.rbacx_factory.build_guard\"\nMIDDLEWARE = [\n    # ...\n    \"rbacx.adapters.django.middleware.RbacxDjangoMiddleware\",\n]\n</code></pre> <p>Use the decorator:</p> <pre><code>from rbacx import Subject, Resource, Action, Context\nfrom rbacx.adapters.django.decorators import require_access\n\ndef build_env(request):\n    uid = getattr(getattr(request, \"user\", None), \"id\", None) or \"anonymous\"\n    return Subject(id=str(uid), roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\n@require_access(build_env, add_headers=True)\ndef doc(request):\n    ...\n</code></pre>"},{"location":"web_adapters/#django-rest-framework-permission","title":"Django REST Framework (permission)","text":"<pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rbacx import Guard, Subject, Resource, Action, Context\nfrom rbacx.adapters.drf import make_permission\n\n\nguard = Guard(policy)\n\ndef build_env(request):\n    uid = getattr(getattr(request, \"user\", None), \"username\", None) or \"anonymous\"\n    return Subject(id=uid, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\nRBACXPermission = make_permission(guard, build_env, add_headers=True)\n\n# Optionally attach headers on 403:\n# REST_FRAMEWORK = {\"EXCEPTION_HANDLER\": \"rbacx.adapters.drf.rbacx_exception_handler\"}\n\nclass DocsView(APIView):\n    permission_classes = [RBACXPermission]\n    def get(self, request):\n        return Response({\"ok\": True})\n</code></pre>"},{"location":"why_choose/","title":"Why choose RBACX","text":""},{"location":"why_choose/#quick-comparison-at-a-glance","title":"Quick Comparison (at a glance)","text":"Criterion RBACX (Python) Casbin (Python) Oso (Polar + Python SDK) Django Guardian django-rules Flask-RBAC Policy definition JSON/YAML/Python dicts (declarative data + operators; includes ReBAC <code>rel</code> condition) Separate <code>model.conf</code> + policy storage (CSV/DB/etc.) Separate <code>.polar</code> files; declarative DSL (Polar) No DSL; permissions stored in DB; backend checks No DSL; rules/predicates registered in Python In-code decorators/config registering role rules Framework integration Adapters for FastAPI, Flask, Django/DRF, Starlette/Litestar (middleware/deps/decorators) Library calls (<code>enforcer.enforce(...)</code>); framework glue typically user-built Enforce via <code>authorize()</code> in app code; ORM filtering helpers Django-only; integrates with <code>user.has_perm</code> and Django Admin Django-only backend; integrates with <code>has_perm</code> &amp; DRF helpers Flask-only; extension + decorators Query-time filtering Manual in app/repo layer Manual or custom helpers Helpers like <code>authorized_query</code> / <code>authorized_resources</code> for ORMs ORM patterns (filter by permissions) Manual (apply predicates or integrate with queryset logic) N/A (endpoint/role checks) ReBAC (relationship checks) Optional <code>RelationshipChecker</code>; optional connectors to external relationship stores (e.g., SpiceDB, OpenFGA) Model via roles/domains or ABAC functions; no first-class relationship graph backend in core usage docs Can model relationships in Polar and filter data; no external graph backend required Object permissions model (per-object grants) Predicate-based checks; no relationship graph Simple role checks; no relationship graph Language scope Python Multi-language ecosystem Libraries for multiple languages Python/Django Python/Django Python/Flask <p>Notes for the table: Casbin uses a <code>model.conf</code> + policy storage (commonly CSV) architecture; Oso policies are written in the Polar language; Guardian provides Django object permissions; <code>django-rules</code> is predicate-based; Flask-RBAC adds RBAC to Flask.</p>"},{"location":"why_choose/#advantages-of-rbacx","title":"Advantages of RBACX","text":"<p>RBACX brings together role-based, attribute-based, and relationship-based access control (ReBAC). You can start with simple role checks and add attribute- or relationship-based conditions later\u2014without changing libraries or architecture. Many alternatives focus either on roles (e.g., Flask-RBAC, Casbin in its simplest use) or a dedicated DSL (e.g., Oso), whereas RBACX supports RBAC + ABAC + ReBAC in one engine. ReBAC can leverage external relationship stores such as SpiceDB or OpenFGA when configured.</p> <ul> <li>Straightforward policy format   Policies are JSON/YAML (or Python dicts). Unlike Casbin (separate model + data) or Oso (a dedicated language), RBACX uses familiar configuration formats that non-programmers can review. The condition DSL is compact but expressive for common business rules. Example:</li> </ul> <pre><code>{\"==\": [ {\"attr\": \"resource.owner\"}, {\"attr\": \"subject.id\"} ]}\n</code></pre> <p>makes the \u201cowner\u201d check explicit. Polar\u2019s equivalent (<code>resource.owner == user</code>) is concise but requires learning a new DSL.</p> <ul> <li> <p>Clean, extensible codebase   RBACX is modular and easy to customize. If you want to store policies in PostgreSQL, implement a <code>PostgresPolicySource</code> and plug it into <code>Guard</code>\u2014no need to fork the library. Casbin is also extensible but has a steeper model/policy abstraction; Oso\u2019s engine centers around a DSL rather than pluggable ports.</p> </li> <li> <p>Adapters for multiple frameworks   Out of the box, RBACX provides adapters for FastAPI/Starlette, Flask, Django, and Litestar. This shortens integration time and enables the same authorization model across services built with different frameworks. In contrast, some alternatives are tied to one framework (Guardian \u2192 Django, Flask-RBAC \u2192 Flask) or require custom glue (Casbin, Oso).</p> </li> <li> <p>Hot policy reload   RBACX can watch file/HTTP/S3 sources and apply policy updates automatically using ETag checks. Guardian, <code>rules</code>, and Flask-RBAC do not provide this out of the box; Casbin supports policy adapters and watchers, and Oso typically reloads programmatically.</p> </li> <li> <p>Explainability, obligations, and ReBAC   RBACX decisions expose not only Permit/Deny but also why (e.g., <code>reason</code>, <code>rule_id</code>) and can include obligations (e.g., require MFA). With ReBAC enabled, the engine can consult a relationship store (e.g., SpiceDB/OpenFGA) through a <code>RelationshipChecker</code> port.</p> </li> <li> <p>Lightweight with minimal dependencies   RBACX keeps the dependency footprint small (e.g., JSON Schema for validation), simplifying installation and reducing exposure to third-party vulnerabilities.</p> </li> <li> <p>Optional decision cache to reduce latency on repeat checks, with safe invalidation on policy change.</p> </li> </ul>"},{"location":"why_choose/#verdict","title":"Verdict","text":"<p>RBACX delivers RBAC + ABAC + ReBAC with a declarative JSON policy model, secure defaults, combining algorithms, hot reload, explainable decisions, and ready-to-use adapters for major Python web frameworks. It\u2019s a pragmatic choice for teams that want fine-grained, auditable authorization without adopting a new policy language. For systems that store permissions as relationships (Google Zanzibar\u2013style), RBACX can delegate checks to proven backends like SpiceDB or OpenFGA.</p> <p>Disclaimer: This page reflects the library author\u2019s perspective. For projects that require 100% reliability proven by years of production use, the choice may lean toward more mature and widely adopted solutions.</p>"},{"location":"rebac/","title":"ReBAC Overview","text":"<p>RBACX supports relationship-based authorization via the <code>rel</code> policy condition and a pluggable <code>RelationshipChecker</code> port.</p>"},{"location":"rebac/#providers","title":"Providers","text":"<ul> <li>Local ReBAC (built-in; no extra)</li> <li>OpenFGA (optional extra) \u2014 Zanzibar-style relationship tuples and a <code>Check</code> API for testing whether a user has a relation to an object.</li> <li>SpiceDB/Authzed (optional extra) \u2014 open-source Zanzibar-inspired permissions database; models relationships (subject\u2013relation\u2013resource) and exposes permission/relationship checks.</li> </ul>"},{"location":"rebac/#how-it-fits","title":"How it fits","text":"<ul> <li>Use <code>rel</code> in policies to assert that the subject holds a given relation to the resource (e.g., <code>\"owner\"</code>, <code>\"editor\"</code>).</li> <li>Configure <code>Guard(..., relationship_checker=...)</code> with your chosen provider (local, OpenFGA, or SpiceDB/Authzed).</li> <li>Fail-closed: if no <code>RelationshipChecker</code> is configured, <code>rel</code> conditions evaluate to <code>false</code>.</li> </ul> <p>See provider-specific pages for setup and examples.</p>"},{"location":"rebac/local/","title":"Local ReBAC (built-in)","text":"<p>The local ReBAC provider ships with RBACX, requires no extra dependencies, and is ideal for tests, demos, and small apps.</p> <p>It evaluates relationship tuples of the form:</p> <pre><code>subject --relation--&gt; resource\n</code></pre> <p>where both <code>subject</code> and <code>resource</code> are string refs like <code>\"type:id\"</code> (e.g., <code>\"user:alice\"</code>, <code>\"document:doc1\"</code>). If <code>\":\"</code> is omitted, the default type is <code>\"user\"</code>.</p>"},{"location":"rebac/local/#userset-primitives","title":"Userset primitives","text":"<p>Local userset-rewrite rules are built from these primitives (they can be nested in lists to mean \u201cunion\u201d):</p> <ul> <li><code>This()</code> \u2014 direct relation on the same object (subject has <code>relation</code> to the current resource).</li> <li><code>ComputedUserset(\"relation\")</code> \u2014 evaluate another relation on the same object.</li> <li><code>TupleToUserset(\"tupleset\", \"computed_userset\")</code> \u2014 follow an object\u2192object edge from the current resource via <code>tupleset</code>, then evaluate <code>computed_userset</code> on the target object.</li> </ul> <p>Type alias used in the API:</p> <pre><code>UsersetExpr = This | ComputedUserset | TupleToUserset | list[\"UsersetExpr\"]\n</code></pre>"},{"location":"rebac/local/#building-tuples-and-rules","title":"Building tuples and rules","text":"<pre><code>from rbacx.rebac.local import (\n    InMemoryRelationshipStore,\n    LocalRelationshipChecker,\n    This, ComputedUserset, TupleToUserset, UsersetExpr\n)\n\n# 1) Relationship tuples (facts)\nstore = InMemoryRelationshipStore()\n\n# Direct user\u2192document relation\nstore.add(\"user:alice\", \"owner\", \"document:doc1\")\n\n# Object\u2192object edges (the 'subject' holds the TARGET object)\n# folder:f1 --parent--&gt; document:doc1  (doc1 is inside folder f1)\nstore.add(\"folder:f1\", \"parent\", \"document:doc1\")\n\n# Group grants: document:doc1 --granted--&gt; group:g1 (expressed as group:g1 'granted' document:doc1)\nstore.add(\"group:g1\", \"granted\", \"document:doc1\")\n# User membership in that group\nstore.add(\"user:alice\", \"member\", \"group:g1\")\n\n# 2) Userset rewrite rules per object type\nrules: dict[str, dict[str, UsersetExpr]] = {\n    \"document\": {\n        # viewer is granted directly, or via owner, parent.folder.viewer, or group grants\n        \"viewer\": [\n            This(),\n            ComputedUserset(\"owner\"),\n            TupleToUserset(\"parent\", \"viewer\"),\n            TupleToUserset(\"granted\", \"member\"),\n        ],\n        \"owner\": [This()],\n        # optional:\n        \"editor\": [This(), ComputedUserset(\"owner\")],\n    },\n    \"folder\": {\n        \"viewer\": [This()],\n    },\n    \"group\": {\n        \"member\": [This()],\n    },\n}\n\nchecker = LocalRelationshipChecker(\n    store,\n    rules=rules,\n    # optional: caveat predicates registry, see below\n    caveat_registry=None,\n    # safety limits (defaults shown)\n    max_depth=8,\n    max_nodes=10_000,\n    deadline_ms=50,\n)\n</code></pre> <p>Tip: for common \u201cviewer/editor/owner (+parent, +group grants)\u201d patterns, see <code>rbacx.rebac.helpers.standard_userset(parent_rel=..., with_group_grants=True)</code>.</p>"},{"location":"rebac/local/#using-rel-in-policy","title":"Using <code>rel</code> in policy","text":"<p>Require that the request\u2019s subject holds a given relation to the resource:</p> <pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"doc-read-if-viewer\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"document\" },\n      \"condition\": { \"rel\": \"viewer\" }\n    }\n  ]\n}\n</code></pre> <p>Extended form (override subject/resource, pass per-check context merged into <code>context._rebac</code>):</p> <pre><code>{\n  \"condition\": {\n    \"rel\": {\n      \"relation\": \"viewer\",\n      \"subject\": \"user:alice\",\n      \"resource\": \"document:doc1\",\n      \"ctx\": { \"reason\": \"delegation\" }\n    }\n  }\n}\n</code></pre> <p>Wire it up:</p> <pre><code>from rbacx import Guard  # or: from rbacx.core.engine import Guard\n\nguard = Guard(policy, relationship_checker=checker)\n</code></pre> <p>See runnable examples in:</p> <ul> <li><code>examples/rebac/rebac_local_demo.py</code></li> <li><code>examples/rebac/rebac_local_demo_with_helper.py</code></li> <li><code>examples/rebac/rebac_more_realistic_demo.py</code></li> </ul>"},{"location":"rebac/local/#safety-limits-caveats","title":"Safety limits &amp; caveats","text":"<p><code>LocalRelationshipChecker</code> enforces soft limits to protect against pathological graphs:</p> <ul> <li><code>max_depth</code>: maximum rewrite recursion depth</li> <li><code>max_nodes</code>: maximum visited nodes</li> <li><code>deadline_ms</code>: time budget per check</li> </ul>"},{"location":"rebac/local/#conditional-tuples-caveats","title":"Conditional tuples (caveats)","text":"<p>You can mark a tuple with a caveat name and provide a predicate via <code>caveat_registry</code>. The predicate receives the merged ReBAC context (<code>context._rebac</code> + <code>ctx</code> from the <code>rel</code> condition) and must return truthy/falsey.</p> <pre><code>def is_business_hours(ctx: dict | None) -&gt; bool:\n    # your logic here (ctx may be None)\n    return bool(ctx and ctx.get(\"hour\", 0) in range(9, 18))\n\nchecker = LocalRelationshipChecker(\n    store,\n    rules=rules,\n    caveat_registry={\"business_hours\": is_business_hours},\n)\n\n# Attach a caveat to a direct relation:\nstore.add(\"user:alice\", \"viewer\", \"document:doc1\", caveat=\"business_hours\")\n</code></pre> <p>In policy, pass <code>ctx</code> if needed:</p> <pre><code>{ \"rel\": { \"relation\": \"viewer\", \"ctx\": { \"hour\": 10 } } }\n</code></pre> <p>Unknown caveats or exceptions inside predicates are treated as False (fail-closed).</p>"},{"location":"rebac/local/#batch-checks","title":"Batch checks","text":"<pre><code># Evaluates sequentially with a small per-call memo to avoid duplicate work.\nresults: list[bool] = checker.batch_check(\n    [(\"user:alice\", \"viewer\", \"document:doc1\"),\n     (\"user:alice\", \"owner\",  \"document:doc1\")]\n)\n</code></pre>"},{"location":"rebac/local/#constructor-reference","title":"Constructor (reference)","text":"<pre><code>LocalRelationshipChecker(\n    store: InMemoryRelationshipStore,\n    *,\n    # rules[object_type][relation] -&gt; UsersetExpr\n    rules: dict[str, dict[str, UsersetExpr]] | None = None,\n    caveat_registry: dict[str, Callable[[dict[str, Any] | None], bool]] | None = None,\n    max_depth: int = 8,\n    max_nodes: int = 10_000,\n    deadline_ms: int = 50,\n)\n</code></pre> <ul> <li><code>InMemoryRelationshipStore.add(subject, relation, resource, caveat=None)</code> stores a tuple (optionally conditional).</li> <li>Direct relations are checked first; userset rewrites (<code>This</code>, <code>ComputedUserset</code>, <code>TupleToUserset</code>) expand the search breadth-first until a match is found or limits are hit.</li> <li>Timeouts/limits result in a False decision for that check.</li> </ul>"},{"location":"rebac/openfga/","title":"OpenFGA Provider","text":"<p>Install: <code>pip install \"rbacx[rebac-openfga]\"</code></p> <pre><code>from rbacx.rebac.openfga import OpenFGAChecker, OpenFGAConfig\n\ncfg = OpenFGAConfig(\n    api_url=\"http://localhost:8080\",     # e.g., https://api.fga.example\n    store_id=\"01H...\",                   # your Store ID\n    authorization_model_id=None,         # optional: can be set here or per-check\n    api_token=None,                      # optional: adds Authorization: Bearer &lt;token&gt;\n)\n\nchecker = OpenFGAChecker(cfg)  # sync and async (httpx) are supported\n</code></pre> <ul> <li>Uses REST endpoints <code>POST /stores/{store_id}/check</code> and <code>POST /stores/{store_id}/batch-check</code>; decisions read the <code>allowed</code> boolean from the response.</li> <li>The server-side Batch Check returns a <code>results</code> array of objects each carrying a <code>correlationId</code> and <code>allowed</code>; ordering is not guaranteed, use <code>correlationId</code> to pair responses to requests. Requires OpenFGA server \u2265 1.8.0.</li> </ul> <p>See <code>deploy/compose/openfga/</code> for a local Docker Compose and <code>deploy/compose/openfga/demo_openfga.py</code>.</p>"},{"location":"rebac/openfga/#configuration-notes","title":"Configuration notes","text":"<ul> <li><code>authorization_model_id</code> (optional) can be set globally in <code>OpenFGAConfig</code> or overridden per request.</li> <li><code>api_token</code> adds the <code>Authorization: Bearer &lt;token&gt;</code> header when your OpenFGA instance requires auth.</li> <li>The checker forwards <code>context</code> from RBACX to OpenFGA so Conditions (conditional relationship tuples) can evaluate it during checks.</li> </ul>"},{"location":"rebac/openfga/#batch-check","title":"Batch Check","text":"<p>When checking many (user, relation, object) tuples:</p> <pre><code>pairs = [\n    (\"user:alice\", \"viewer\", \"document:doc1\", \"1\"),\n    (\"user:alice\", \"editor\", \"document:doc1\", \"2\"),\n    (\"user:alice\", \"owner\",  \"document:doc1\", \"3\"),\n]\nresult = checker.batch_check(pairs)\n# result[\"results\"] -&gt; list of {\"correlationId\": \"...\", \"allowed\": bool, \"request\": {...}}\n</code></pre> <p>The provider sets a <code>correlationId</code> per input; the server responds with a <code>results</code> array (not a map).</p> <p>Read more: * Concepts * Relationship Queries: Check, Read, Expand, and ListObjects * Conditions</p>"},{"location":"rebac/spicedb/","title":"SpiceDB / Authzed Provider","text":"<p>Install: <code>pip install \"rbacx[rebac-spicedb]\"</code></p> <pre><code>from rbacx.rebac.spicedb import SpiceDBChecker, SpiceDBConfig\n\ncfg = SpiceDBConfig(\n    endpoint=\"localhost:50051\",  # gRPC endpoint\n    insecure=True,               # plaintext gRPC for local/dev; use TLS in prod\n    token=None,                  # optional Bearer token (Authorization: Bearer &lt;token&gt;)\n    deadline_ms=200,             # optional per-check deadline\n)\n\nchecker = SpiceDBChecker(cfg)    # sync by default; optional async if available\n</code></pre> <ul> <li>Uses gRPC PermissionService.CheckPermission; a check is permitted when <code>permissionship == PERMISSIONSHIP_HAS_PERMISSION</code>.</li> <li>Supports bulk evaluations via CheckBulkPermissions to reduce round-trips.</li> <li>Sync by default; async mode can be used if your environment provides an async client (e.g., <code>authzed</code> async stubs). Otherwise, use the sync client.</li> </ul> <p>See <code>deploy/compose/spicedb/</code> for a local Docker Compose and <code>deploy/compose/spicedb/demo.py</code>. For general Docker install docs, see the official guide.</p>"},{"location":"rebac/spicedb/#configuration-notes","title":"Configuration notes","text":"<ul> <li> <p>Consistency   You can request consistency using a ZedToken (<code>at_least_as_fresh</code>) or force <code>fully_consistent=True</code>. Prefer ZedTokens for better cache hit rates and lower latency where possible.</p> </li> <li> <p>Context &amp; caveats   ReBAC context is forwarded to SpiceDB as a <code>google.protobuf.Struct</code>, enabling evaluation of caveats defined in your schema.</p> </li> <li> <p>TLS vs insecure <code>insecure=True</code> uses a plaintext (non-TLS) channel (suitable for local Docker/CI) and a raw Bearer token; otherwise, use a TLS client with bearer credentials for production.</p> </li> <li> <p>Async client (optional)   If your installed <code>authzed</code> client exposes async stubs, the checker can operate asynchronously; note that some insecure-channel variants may have limitations around async transports.</p> </li> </ul>"},{"location":"rebac/spicedb/#batch-check","title":"Batch Check","text":"<p>When checking many <code>(subject, relation/permission, resource)</code> tuples, the checker uses CheckBulkPermissions in one call:</p> <pre><code>pairs = [\n    (\"user:alice\", \"viewer\", \"document:doc1\"),\n    (\"user:alice\", \"editor\", \"document:doc1\"),\n    (\"user:alice\", \"owner\",  \"document:doc1\"),\n]\n\nresults: list[bool] = checker.batch_check(pairs)\n# results[i] corresponds to pairs[i] and is True iff permissionship == HAS_PERMISSION\n</code></pre> <p>Use a single ZedToken across a batch/flow for consistent reads.</p> <p>Read more: * PermissionService (gRPC) \u2014 CheckPermission / CheckBulkPermissions * Consistency &amp; ZedTokens * Caveats &amp; context * Install SpiceDB with Docker</p>"}]}