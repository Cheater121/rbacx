{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RBACX","text":"<p>RBAC + ABAC authorization for Python with a clean architecture, declarative JSON policies, framework adapters, and optional hot reloading.</p>"},{"location":"#inspiration-philosophy","title":"Inspiration &amp; Philosophy","text":"<p>RBACX is inspired by: - OWASP-aligned practices like deny by default and least privilege. - The recurring pain for Python developers switching between projects with inconsistent authorization stacks. - The XACML model (policies, rules, effects, combining algorithms, obligations), simplified and made friendlier for web developers using JSON and a Python-first API.</p> <p>Our philosophy: security should be understandable and ergonomic for developers so that correct authorization becomes the path of least resistance.</p>"},{"location":"#what-you-get","title":"What you get","text":"<ul> <li>RBAC + ABAC in a single engine (role checks + attribute conditions).</li> <li>Declarative policies (JSON/YAML or Python dict) with compact operators, including time operators.</li> <li>Secure defaults: <code>deny-overrides</code> by default; also <code>permit-overrides</code>, <code>first-applicable</code>.</li> <li>Role hierarchy via resolvers (<code>StaticRoleResolver</code> and custom implementations).</li> <li>Explainable decisions (<code>allowed</code>, <code>effect</code>, <code>reason</code>, <code>rule_id</code>) and obligations (e.g., require MFA).</li> <li>Hot reload from file/HTTP/S3 using ETag checks.</li> <li>Adapters for FastAPI/Starlette, Flask, Django/DRF, Litestar.</li> <li>Observability: logging hooks and metrics sinks (Prometheus/OpenTelemetry).</li> <li>CLI &amp; linting: <code>rbacx validate</code> to validate policies.</li> <li>Test coverage around 82% across core decision paths.</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#1-install","title":"1) Install","text":"<pre><code>pip install rbacx\n</code></pre>"},{"location":"#2-define-a-minimal-policy-json","title":"2) Define a minimal policy (JSON)","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"allow_read_public\",\n      \"target\": { \"resource\": { \"type\": \"document\" }, \"action\": \"read\" },\n      \"condition\": { \"==\": [ { \"attr\": \"resource.visibility\" }, \"public\" ] },\n      \"effect\": \"permit\",\n      \"obligations\": [{ \"type\": \"require_mfa\", \"when\": true }]\n    }\n  ]\n}\n</code></pre>"},{"location":"#3-evaluate-in-python","title":"3) Evaluate in Python","text":"<pre><code>from rbacx import Guard\n\npolicy = {...}  # load JSON as a dict\ng = Guard(policy)\n\ndecision = g.evaluate_sync(\n    subject={\"id\": \"u1\", \"roles\": [\"reader\"]},\n    action=\"read\",\n    resource={\"type\": \"document\", \"visibility\": \"public\"},\n    context={\"mfa\": True},\n)\n\nassert decision.allowed is True\nprint(decision.effect, decision.reason, decision.rule_id, decision.obligations)\n</code></pre>"},{"location":"#4-optional-use-a-web-adapter","title":"4) (Optional) Use a web adapter","text":"<p>FastAPI <pre><code>from fastapi import FastAPI\nfrom rbacx.adapters.fastapi import require_access\nfrom rbacx import Guard\n\napp = FastAPI()\n\npolicy = {...}  # reuse the policy from above or define one here\nguard = Guard(policy)\n\ndef build_env(request):\n    # map request -&gt; (subject, action, resource, context)\n    return {\n        \"subject\": {\"id\": request.headers.get(\"X-User\"), \"roles\": [\"reader\"]},\n        \"action\": request.method.lower(),\n        \"resource\": {\"type\": \"document\", \"path\": request.url.path},\n        \"context\": {\"mfa\": True},\n    }\n\n@app.get(\"/docs\")\n@require_access(guard, build_env)\ndef docs():\n    return {\"ok\": True}\n</code></pre></p>"},{"location":"#documentation-map","title":"Documentation map","text":"<p>Start here - Quickstart - Why choose RBACX - Highlights</p> <p>Core concepts - Architecture - Security model - Explainability (reasons &amp; obligations) - Role hierarchy - Audit mode</p> <p>Policy - Policy authoring - Policy catalog - Time operators - Policy loading (hot reload) - Policy stores - HTTP mapping</p> <p>Integration - Web adapters - Adapters (API) - Try examples</p> <p>Observability - Metrics - OpenTelemetry - Logging - Diagnostics - Observability stack</p> <p>Performance &amp; operations - Performance guide - Benchmarks - CI - Migration (RBAC\u2192ABAC)</p> <p>Reference - Public API</p>"},{"location":"adapters/","title":"Adapters","text":"<p>FastAPI / Flask / Litestar / Django examples are under <code>examples/</code>.</p>"},{"location":"adapters/#enforcement-helpers","title":"Enforcement helpers","text":""},{"location":"adapters/#fastapi","title":"FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends, Request\nfrom rbacx.adapters.fastapi import require_access\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\n# Demo policy (permit-all for brevity)\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    user = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = FastAPI()\n\n@app.get(\"/secure\", dependencies=[Depends(require_access(guard, build_env, add_headers=True))])\ndef secure():\n    return {\"ok\": True}\n</code></pre>"},{"location":"adapters/#flask","title":"Flask","text":"<pre><code>from flask import Flask, request\nfrom rbacx.adapters.flask import require_access\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\n# Demo policy (permit-all for brevity)\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy)\n\ndef build_env(req=None):\n    req = req or request\n    user = req.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = Flask(__name__)\n\n@app.get(\"/secure\")\n@require_access(guard, build_env, add_headers=True)\ndef secure():\n    return {\"ok\": True}\n</code></pre>"},{"location":"adapters/#django","title":"Django","text":"<pre><code>from rbacx.adapters.django.decorators import require\n\n@require(\"read\", \"doc\")\ndef my_view(request):\n    # Tip: provide request.rbacx_guard via RbacxDjangoMiddleware\n    ...\n</code></pre>"},{"location":"adapters/#litestar","title":"Litestar","text":"<pre><code>from litestar import Litestar, get\nfrom litestar.di import Provide\nfrom rbacx.adapters.litestar_guard import require\nfrom rbacx import Guard\n\n# Demo policy (permit-all for brevity)\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy)\n\n@get(\n    \"/secure\",\n    dependencies={\n        \"check\": Provide(require(\"read\", \"doc\")),   # performs the access check\n        \"guard\": Provide(lambda: guard),            # injected into the checker\n    },\n)\ndef secure() -&gt; dict:\n    return {\"ok\": True}\n\napp = Litestar(route_handlers=[secure])\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Policy package (hot reloader, etc.).</p>"},{"location":"api/#rbacx.core.engine.Guard","title":"<code>Guard(policy, *, logger_sink=None, metrics=None, obligation_checker=None, role_resolver=None)</code>","text":"<p>Policy evaluation engine.</p> <p>Holds a policy or a policy set and evaluates access decisions.</p> Design <ul> <li>Single async core <code>_evaluate_core_async</code> (one source of truth).</li> <li>Sync API wraps the async core; if a loop is already running, uses a helper thread.</li> <li>DI (resolver/obligations/metrics/logger) can be sync or async; both supported via <code>_maybe_await</code>.</li> <li>CPU-bound evaluation is offloaded to a thread via <code>asyncio.to_thread</code>.</li> <li>On init we ensure a current event loop exists in this thread so   legacy tests using <code>asyncio.get_event_loop().run_until_complete(...)</code>   don\u2019t crash on Python 3.12+.</li> </ul>"},{"location":"api/#rbacx.core.engine.Guard.evaluate_async","title":"<code>evaluate_async(subject, action, resource, context=None)</code>  <code>async</code>","text":"<p>True async API for ASGI frameworks.</p>"},{"location":"api/#rbacx.core.engine.Guard.evaluate_sync","title":"<code>evaluate_sync(subject, action, resource, context=None)</code>","text":"<p>Synchronous wrapper for the async core. - If no running loop in this thread: use asyncio.run(...) - If a loop is running: run the async core in a helper thread with its own loop.</p>"},{"location":"api/#rbacx.core.engine.Guard.set_policy","title":"<code>set_policy(policy)</code>","text":"<p>Replace policy/policyset.</p>"},{"location":"api/#rbacx.core.engine.Guard.update_policy","title":"<code>update_policy(policy)</code>","text":"<p>Alias kept for backward-compatibility.</p>"},{"location":"api/#rbacx.core.policy.ConditionTypeError","title":"<code>ConditionTypeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a condition compares incompatible types.</p>"},{"location":"api/#rbacx.core.policy.eval_condition","title":"<code>eval_condition(cond, env)</code>","text":"<p>Evaluate condition dict safely. On type mismatches, raise ConditionTypeError.</p>"},{"location":"api/#rbacx.core.policy.resolve","title":"<code>resolve(token, env)</code>","text":"<p>Resolve a token; supports {\"attr\": \"a.b.c\"} lookups in env.</p>"},{"location":"api/#rbacx.core.policyset.decide","title":"<code>decide(policyset, env)</code>","text":"<p>Evaluate a policy set with combining algorithm over its child policies.</p>"},{"location":"api/#rbacx.core.ports.RoleResolver","title":"<code>RoleResolver</code>","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/#rbacx.core.ports.RoleResolver.expand","title":"<code>expand(roles)</code>","text":"<p>Return roles including inherited/derived ones.</p>"},{"location":"api/#rbacx.store.FilePolicySource","title":"<code>FilePolicySource(path, *, validate_schema=False, include_mtime_in_etag=False, chunk_size=512 * 1024)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by a local JSON file.</p> ETag semantics <ul> <li>By default, ETag = SHA-256 of file content.</li> <li>If include_mtime_in_etag=True, the ETag also includes mtime (ns),   so a simple \"touch\" (metadata-only change) will trigger a reload.</li> </ul> <p>The class caches the last SHA by (size, mtime_ns) to avoid unnecessary hashing.</p>"},{"location":"api/#rbacx.store.HTTPPolicySource","title":"<code>HTTPPolicySource(url, *, headers=None)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>HTTP policy source using <code>requests</code> with ETag support. Extra: rbacx[http]</p>"},{"location":"api/#rbacx.store.S3PolicySource","title":"<code>S3PolicySource(url, *, client=None, session=None, config=None, client_extra=None, validate_schema=True, change_detector='etag', prefer_checksum='sha256')</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by Amazon S3.</p> <p>Change detection strategies (choose one via <code>change_detector</code>):   - \"etag\"        : HeadObject ETag (default).   - \"version_id\"  : HeadObject VersionId (requires bucket versioning).   - \"checksum\"    : GetObjectAttributes(..., ObjectAttributes=['Checksum']) if available.</p> <p>Networking defaults are production-friendly (timeouts + retries) and can be overridden via a custom botocore Config or client parameters.</p>"},{"location":"api/#rbacx.store.S3PolicySource.etag","title":"<code>etag()</code>","text":"<p>Return the current change marker according to <code>change_detector</code>.</p>"},{"location":"api/#rbacx.store.S3PolicySource.load","title":"<code>load()</code>","text":"<p>Download and parse the policy document from S3.</p> <p>The format (JSON vs YAML) is auto-detected using the object key (filename) and/or content.</p>"},{"location":"api/#rbacx.store.atomic_write","title":"<code>atomic_write(path, data, *, encoding='utf-8')</code>","text":"<p>Write data atomically to path using a temp file + os.replace().</p>"},{"location":"api/#rbacx.policy.HotReloader","title":"<code>HotReloader(guard, source, *, initial_load=False, poll_interval=5.0, backoff_min=2.0, backoff_max=30.0, jitter_ratio=0.15, thread_daemon=True)</code>","text":"<p>Unified, production-grade policy reloader.</p> Features <ul> <li>ETag-first logic: call source.etag() and only load/apply when it changes.</li> <li>Error suppression with exponential backoff + jitter to avoid log/IO storms.</li> <li>Optional background polling loop with clean start/stop.</li> <li>Backwards-compatible one-shot API aliases: refresh_if_needed()/poll_once().</li> </ul> Notes <ul> <li>If source.etag() returns None, we will attempt to load() and let the source decide.</li> <li>Guard.set_policy(policy) is called only after a successful load().</li> <li>This class is thread-safe for concurrent check_and_reload() calls.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial_load</code> <code>bool</code> <p>Controls startup behavior.   - False (default): prime ETag at construction time; the first check will NO-OP     unless the policy changes. (Backwards-compatible with previous versions.)   - True: do not prime ETag; the first check will load the current policy.</p> <code>False</code>"},{"location":"api/#rbacx.policy.HotReloader.check_and_reload","title":"<code>check_and_reload(*, force=False)</code>","text":"<p>Perform a single reload check (sync wrapper over the async core).</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>If True, load/apply the policy regardless of ETag state.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if a new policy was loaded and applied; otherwise False.</p>"},{"location":"api/#rbacx.policy.HotReloader.check_and_reload_async","title":"<code>check_and_reload_async(*, force=False)</code>  <code>async</code>","text":"Async-aware reload check <ul> <li>supports sync/async PolicySource.etag()/load() via _maybe_await</li> <li>never holds the thread lock while awaiting</li> </ul>"},{"location":"api/#rbacx.policy.HotReloader.start","title":"<code>start(interval=None, *, initial_load=None, force_initial=False)</code>","text":"<p>Start the background polling thread.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float | None</code> <p>seconds between checks; if None, uses self.poll_interval (or 5.0 fallback).</p> <code>None</code> <code>initial_load</code> <code>Optional[bool]</code> <p>override constructor's initial_load just for this start().           If True, perform a synchronous load/check before starting the thread.           If False, skip any initial load.           If None, inherit the constructor setting.</p> <code>None</code> <code>force_initial</code> <code>bool</code> <p>if True and an initial load is requested, bypass the ETag check            for that initial load (equivalent to check_and_reload(force=True)).</p> <code>False</code>"},{"location":"api/#rbacx.policy.HotReloader.stop","title":"<code>stop(timeout=1.0)</code>","text":"<p>Signal the polling thread to stop and optionally wait for it.</p>"},{"location":"api/#rbacx.store.file_store.FilePolicySource","title":"<code>FilePolicySource(path, *, validate_schema=False, include_mtime_in_etag=False, chunk_size=512 * 1024)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by a local JSON file.</p> ETag semantics <ul> <li>By default, ETag = SHA-256 of file content.</li> <li>If include_mtime_in_etag=True, the ETag also includes mtime (ns),   so a simple \"touch\" (metadata-only change) will trigger a reload.</li> </ul> <p>The class caches the last SHA by (size, mtime_ns) to avoid unnecessary hashing.</p>"},{"location":"api/#rbacx.store.file_store.atomic_write","title":"<code>atomic_write(path, data, *, encoding='utf-8')</code>","text":"<p>Write data atomically to path using a temp file + os.replace().</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource","title":"<code>S3PolicySource(url, *, client=None, session=None, config=None, client_extra=None, validate_schema=True, change_detector='etag', prefer_checksum='sha256')</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>Policy source backed by Amazon S3.</p> <p>Change detection strategies (choose one via <code>change_detector</code>):   - \"etag\"        : HeadObject ETag (default).   - \"version_id\"  : HeadObject VersionId (requires bucket versioning).   - \"checksum\"    : GetObjectAttributes(..., ObjectAttributes=['Checksum']) if available.</p> <p>Networking defaults are production-friendly (timeouts + retries) and can be overridden via a custom botocore Config or client parameters.</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource.etag","title":"<code>etag()</code>","text":"<p>Return the current change marker according to <code>change_detector</code>.</p>"},{"location":"api/#rbacx.store.s3_store.S3PolicySource.load","title":"<code>load()</code>","text":"<p>Download and parse the policy document from S3.</p> <p>The format (JSON vs YAML) is auto-detected using the object key (filename) and/or content.</p>"},{"location":"api/#rbacx.store.http_store.HTTPPolicySource","title":"<code>HTTPPolicySource(url, *, headers=None)</code>","text":"<p>               Bases: <code>PolicySource</code></p> <p>HTTP policy source using <code>requests</code> with ETag support. Extra: rbacx[http]</p>"},{"location":"api/#rbacx.adapters.flask.require_access","title":"<code>require_access(guard, build_env, *, add_headers=False)</code>","text":"<p>Decorator for Flask view functions to enforce access.</p>"},{"location":"api/#rbacx.adapters.litestar.RBACXMiddleware","title":"<code>RBACXMiddleware(app, *, guard, build_env)</code>","text":"<p>               Bases: <code>AbstractMiddleware</code></p> <p>Litestar middleware that checks access using RBACX Guard.</p> <p>Configure with a function <code>build_env(scope) -&gt; (Subject, Action, Resource, Context)</code>.</p>"},{"location":"api/#decision-object","title":"Decision object","text":"<p>Fields returned by <code>Guard.evaluate*</code>:</p> <ul> <li><code>allowed: bool</code></li> <li><code>effect: \"permit\" | \"deny\"</code></li> <li><code>obligations: List[Dict[str, Any]]</code></li> <li><code>challenge: Optional[str]</code></li> <li><code>rule_id: Optional[str]</code></li> <li><code>policy_id: Optional[str]</code></li> <li><code>reason: Optional[str]</code></li> </ul>"},{"location":"api/#yaml-policies","title":"YAML policies","text":"<p>All built-in policy sources accept JSON and, with the optional <code>rbacx[yaml]</code> extra, YAML.</p> <ul> <li>File: detected by extension <code>.yaml</code> / <code>.yml</code>.</li> <li>HTTP: detected by <code>Content-Type</code> (e.g., <code>application/yaml</code>, <code>application/x-yaml</code>, <code>text/yaml</code>) or URL suffix.</li> <li>S3: detected by key suffix <code>.yaml</code> / <code>.yml</code>.</li> </ul> <p>Internally YAML is parsed and validated against the same JSON Schema as JSON.</p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart LR\n  UI[Frameworks] --&gt;|adapters| Core\n  Storage[Policy Sources] --&gt; Core\n  Telemetry[Decision Logger] --&gt; Core\n  Core[rbacx.core: Guard/Policy/Obligations]</code></pre>"},{"location":"audit_mode/","title":"Audit mode","text":"<p>RBACX can log authorization decisions for observability without enforcing them.</p>"},{"location":"audit_mode/#how-it-works","title":"How it works","text":"<ul> <li>Pass a <code>DecisionLogSink</code> implementation (e.g., <code>DecisionLogger</code>) to <code>Guard</code> via <code>logger_sink=...</code>.</li> <li>Each decision is emitted to the Python logger <code>rbacx.audit</code>. Set <code>as_json=True</code> to serialize the event as JSON; otherwise a compact text form (<code>decision {...}</code>) is logged. You can also control the log level via the <code>level</code> parameter.</li> <li>Optional sampling (<code>sample_rate</code>) helps manage log volume in high-traffic environments.</li> <li>Redactions reuse obligation formats (e.g. <code>\"mask_fields\"</code>, <code>\"redact_fields\"</code>) and are applied before the event is logged; if a listed field is missing in the request context, the enforcer will still create it in the logged <code>env</code> with the appropriate placeholder (mask or <code>[REDACTED]</code>).</li> <li>It is best practice to log security-relevant events using structured/centralized logs, and to avoid logging sensitive fields.</li> </ul>"},{"location":"audit_mode/#example-framework-agnostic","title":"Example (framework-agnostic)","text":"<pre><code>import logging\nfrom rbacx import Guard\nfrom rbacx.logging.decision_logger import DecisionLogger\n\naudit = logging.getLogger(\"rbacx.audit\")\naudit.setLevel(logging.INFO)\naudit.addHandler(logging.StreamHandler())\n\ndecision_logger = DecisionLogger(\n    sample_rate=0.1,\n    redactions=[{\"type\": \"mask_fields\", \"fields\": [\"subject.email\", \"resource.attrs.card\"]}],\n    as_json=True,              # new: emit JSON\n    level=logging.INFO,        # new: configurable log level\n)\n\npolicy = {\"algorithm\":\"deny-overrides\",\"rules\":[]}\n\nguard = Guard(policy, logger_sink=decision_logger)\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks helper","text":"<p>Run the included micro-benchmark to compare PDP latency for different policy sizes:</p> <pre><code>python bench/bench_pdp.py --sizes 10 100 500 1000 --iters 500\n</code></pre> <p>It prints CSV to stdout (<code>size,avg_ms,p50_ms,p90_ms,allowed</code>). Use it only for relative comparisons in your environment.</p>"},{"location":"ci/","title":"CI","text":"<p>Suggested checks: - Tests: <code>pytest -q</code> - Lint: <code>ruff check</code> - Types: <code>mypy src</code> - Build: <code>python -m build</code> (sdist + wheel)</p>"},{"location":"custom_policy_source/","title":"Creating a Custom <code>PolicySource</code> (concise + best practices)","text":"<p>RBACX accepts any object that implements the <code>PolicySource</code> protocol:</p> <pre><code>class PolicySource(Protocol):\n    def load(self) -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]: ...\n    def etag(self) -&gt; Optional[str] | Awaitable[Optional[str]]: ...\n</code></pre> <p>Built-ins: File, HTTP (sync), and S3 (sync) sources already ship with RBACX. But you can write your own \u2014 including async sources. This page keeps one small example (in-memory) and focuses on how to design your own source robustly.</p>"},{"location":"custom_policy_source/#minimal-in-memory-source","title":"Minimal in-memory source","text":"<pre><code>from typing import Any, Dict, Optional\nfrom rbacx import HotReloader, Guard\nfrom rbacx.core.ports import PolicySource\n\nclass MemorySource(PolicySource):\n    def __init__(self, policy: Dict[str, Any], etag: str = \"v1\"):\n        self._policy = policy\n        self._etag = etag\n\n    def etag(self) -&gt; Optional[str]:\n        # Return a cheap, stable version for the current policy\n        return self._etag\n\n    def load(self) -&gt; Dict[str, Any]:\n        # Return a dict representing a Policy or PolicySet\n        return self._policy\n\n# Usage\nguard = Guard(policy={\"rules\": []})\nsrc = MemorySource(policy={\n    \"rules\": [\n        {\"id\": \"allow_read\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}, \"effect\": \"permit\"}\n    ]\n}, etag=\"v2\")\nreloader = HotReloader(guard, src, initial_load=True)  # loads immediately when etag differs\n</code></pre>"},{"location":"custom_policy_source/#design-guidelines-what-good-sources-do","title":"Design guidelines (what good sources do)","text":"<ul> <li> <p>Cheap/stable versioning via <code>etag()</code></p> </li> <li> <p>Return a value that changes only when the policy changes (hash, version id, last-modified, etc.).</p> </li> <li> <p>Prefer values your backend already guarantees (e.g., HTTP <code>ETag</code>, S3 <code>VersionId</code>). If not available, compute one (e.g., hash) in <code>load()</code> and cache it. For HTTP, <code>ETag</code> and conditional requests (<code>If-None-Match</code> \u2192 <code>304 Not Modified</code>) minimize transfer and are standard practice.</p> </li> <li> <p>Deterministic <code>load()</code></p> </li> <li> <p>Always return a fully parsed <code>dict</code> (Policy or PolicySet), never partially filled structures.</p> </li> <li> <p>Validate input if you transform from YAML \u2192 JSON, and fail fast on invalid schema.</p> </li> <li> <p>Resilience &amp; fairness</p> </li> <li> <p>For remote backends: use timeouts, retries, exponential backoff with jitter, and a max backoff cap.</p> </li> <li> <p>Surface meaningful exceptions in logs; don\u2019t swallow permanent errors.</p> </li> <li> <p>Integrity &amp; security</p> </li> <li> <p>Verify payload integrity when possible (signed artifact, checksum, or versioned objects).</p> </li> <li>Secure transport: TLS; consider mTLS / pinning for internal services.</li> <li> <p>For HTTP caches/validators, see HTTP semantics (RFC 9110) for strong/weak validators and conditional requests. </p> </li> <li> <p>Sensible defaults</p> </li> <li> <p>If <code>etag()</code> can\u2019t be computed upfront, return <code>None</code>; <code>HotReloader</code> will still call <code>load()</code> when forced or on scheduled runs.</p> </li> <li>Keep <code>load()</code> side-effect free (no writes).</li> </ul>"},{"location":"custom_policy_source/#async-sources-with-httpx-example","title":"Async sources with <code>httpx</code> (example)","text":"<p>RBACX\u2019s <code>HotReloader</code> supports both sync and async <code>PolicySource</code> implementations. Below is a production-style async HTTP source using <code>httpx</code>:</p> <ul> <li>Uses <code>httpx.AsyncClient</code> with explicit timeouts. Default HTTPX timeouts are \\~5s of inactivity; set your own per your SLOs. </li> <li>Supports ETag caching and conditional GET via <code>If-None-Match</code> to receive <code>304 Not Modified</code> when the policy hasn\u2019t changed. </li> <li>Implements capped exponential backoff with jitter on transient failures \u2014 no extra dependencies.</li> </ul> <pre><code>import asyncio\nimport json\nimport math\nimport random\nfrom typing import Any, Dict, Optional\n\nimport httpx  # pip install https\n\nfrom rbacx.core.ports import PolicySource\n\n\nclass AsyncHTTPPolicySource(PolicySource):\n    \"\"\"\n    Async PolicySource that fetches a JSON policy from an HTTP endpoint.\n\n    - Caches ETag and last good policy in-memory.\n    - Uses conditional requests (If-None-Match) to avoid re-downloading unchanged payloads.\n    - Applies capped exponential backoff with jitter on transient errors.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        timeout: float = 5.0,\n        max_retries: int = 3,\n        backoff_base: float = 0.5,\n        backoff_cap: float = 8.0,\n        http2: bool = False,\n        verify: bool | str = True,\n    ) -&gt; None:\n        self._url = url\n        self._timeout = timeout\n        self._max_retries = max_retries\n        self._backoff_base = backoff_base\n        self._backoff_cap = backoff_cap\n        self._etag: Optional[str] = None\n        self._cached_policy: Optional[Dict[str, Any]] = None\n        self._client = httpx.AsyncClient(http2=http2, verify=verify)\n\n    async def close(self) -&gt; None:\n        await self._client.aclose()\n\n    # ---- PolicySource API -------------------------------------------------\n\n    async def etag(self) -&gt; Optional[str]:\n        # If we've seen an ETag before, return it cheaply.\n        if self._etag is not None:\n            return self._etag\n        # Otherwise, try to fetch headers via a HEAD; fallback to GET if HEAD not allowed.\n        try:\n            r = await self._client.head(self._url, timeout=self._timeout)\n            if r.status_code == 405:  # Method Not Allowed -&gt; fall back to GET headers\n                r = await self._client.get(self._url, headers={\"Range\": \"bytes=0-0\"}, timeout=self._timeout)\n            r.raise_for_status()\n            et = r.headers.get(\"ETag\")\n            if et:\n                self._etag = et\n            return self._etag\n        except Exception:\n            # If anything fails, signal unknown etag; the reloader can still force-load.\n            return None\n\n    async def load(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetch and parse the policy JSON. Uses If-None-Match to avoid full body when unchanged.\n        Retries transient failures with capped exponential backoff + jitter.\n        \"\"\"\n        last_etag = self._etag\n        headers = {\"Accept\": \"application/json\"}\n        if last_etag:\n            headers[\"If-None-Match\"] = last_etag\n\n        attempt = 0\n        while True:\n            try:\n                r = await self._client.get(self._url, headers=headers, timeout=self._timeout)\n                # 304: unchanged -&gt; return cached policy if available\n                if r.status_code == 304 and self._cached_policy is not None:\n                    return self._cached_policy\n\n                r.raise_for_status()\n                # Success path: parse JSON, update cache + etag\n                policy = r.json()\n                if not isinstance(policy, dict):\n                    raise ValueError(\"policy must be a JSON object\")\n                self._etag = r.headers.get(\"ETag\", self._etag)\n                self._cached_policy = policy\n                return policy\n\n            except (httpx.ConnectError, httpx.ReadTimeout, httpx.RemoteProtocolError, httpx.HTTPStatusError) as e:\n                # Retry on common transient network/protocol errors and 5xx responses\n                if isinstance(e, httpx.HTTPStatusError) and (400 &lt;= e.response.status_code &lt; 500) and e.response.status_code != 429:\n                    # Non-retryable 4xx (except 429)\n                    raise\n                attempt += 1\n                if attempt &gt; self._max_retries:\n                    raise\n                # Exponential backoff with full jitter\n                base = self._backoff_base * (2 ** (attempt - 1))\n                sleep_s = min(self._backoff_cap, base) * random.uniform(0.0, 1.0)\n                await asyncio.sleep(sleep_s)\n</code></pre> <p>Notes</p> <ul> <li>HTTP semantics for ETags and conditional requests: MDN (<code>ETag</code>, <code>If-None-Match</code>, <code>304</code>) and RFC 9110 are the authoritative references. </li> <li>HTTPX async client, timeouts, and options (e.g., <code>http2</code>, <code>verify</code>): see official docs. </li> <li>Backoff with jitter is recommended to avoid retry storms. </li> </ul>"},{"location":"custom_policy_source/#using-it-with-the-reloader","title":"Using it with the reloader","text":"<pre><code>from rbacx import Guard, HotReloader\n\nguard = Guard(policy={\"rules\": []})\nsrc = AsyncHTTPPolicySource(\"https://policies.example.com/current.json\", http2=True, timeout=3.0)\n\n# One-shot (sync), even inside an async app:\nchanged = HotReloader(guard, src).check_and_reload(force=True)  # the reloader handles event loop bridging\n\n# Or async:\n# changed = await HotReloader(guard, src).check_and_reload_async(force=True)\n</code></pre> <p>Cleanup: If you construct long-lived sources, remember to close the <code>AsyncClient</code> when done:</p> <pre><code>await src.close()\n</code></pre>"},{"location":"custom_policy_source/#operational-tips","title":"Operational tips","text":"<ul> <li>Polling: Pick an interval that fits your update cadence; add small random jitter to reduce thundering herds. For HTTP, prefer conditional requests so unchanged policies return <code>304 Not Modified</code>. </li> <li>Observability: Log failures with context (source, attempt, delay), add metrics (reload success/failure, last apply time).</li> <li>Circuit-breakers: If your backend is unstable, short-circuit after N attempts and try later.</li> <li>Rollouts: Version your policies; keep a quick rollback path (e.g., previous <code>VersionId</code> / artifact).</li> </ul>"},{"location":"custom_policy_source/#testing-your-source","title":"Testing your source","text":"<ul> <li>Unit: Prove <code>etag()</code> stability for no-change scenarios; verify change detection and that <code>load()</code> rejects malformed data.</li> <li>Integration: Exercise <code>HotReloader.check_and_reload(force=True)</code> and the background <code>start()/stop()</code> loop.</li> <li>Failure modes: Simulate timeouts/5xx and ensure backoff+jitter take effect and logs are clear. AWS guidance on timeouts/retries/jitter is a good reference. </li> </ul>"},{"location":"custom_policy_source/#checklist","title":"Checklist","text":"<ul> <li>[ ] <code>etag()</code> returns a cheap, stable value that changes only when policy changes (or <code>None</code> if unknown).</li> <li>[ ] <code>load()</code> returns a valid dict (Policy/PolicySet).</li> <li>[ ] Remote backends: timeouts, retries, exponential backoff with jitter, max cap.</li> <li>[ ] Integrity/security measures in place (versioning, checksums, signatures, TLS/mTLS).</li> <li>[ ] Good logs/metrics for visibility; clear rollback path.</li> </ul>"},{"location":"diagnostics/","title":"Policy diagnostics","text":"<p>RBACX ships a simple linter to catch common authoring pitfalls:</p> <ul> <li>MISSING_ID \u2013 each rule should have a stable <code>id</code> for auditing.</li> <li>DUPLICATE_ID \u2013 ids must be unique per policy.</li> <li>EMPTY_ACTIONS \u2013 avoid rules without actions.</li> <li>BROAD_RESOURCE \u2013 <code>resource.type</code> is <code>*</code> or missing; narrow scope.</li> <li>POTENTIALLY_UNREACHABLE \u2013 with <code>first-applicable</code>, a later rule is unreachable if an earlier one with the same effect already covers its actions/resource.</li> </ul> <p>Run: <pre><code>rbacx lint --policy policy.json\n</code></pre></p> <p>Note: this linter is heuristic by design. It focuses on high-signal checks without full SAT solving.</p> <p>Additional heuristics: - ALWAYS_TRUE \u2013 the condition is trivially true (e.g., <code>{\"==\":[X, X]}</code>); the rule may be overly broad. - ALWAYS_FALSE \u2013 the condition is trivially false (e.g., <code>{\"!=\":[X, X]}</code>); the rule will never match.</p> <p>We intentionally avoid a <code>regex</code> operator to reduce ReDoS risk. If you add regex matching, prefer safe engines (RE2) and timeouts.</p>"},{"location":"highlights/","title":"Highlights of RBACX","text":""},{"location":"highlights/#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>Core vs. Adapters: Authorization decision logic lives in <code>rbacx.core</code> (e.g., <code>Guard</code>), while framework-specific integration is implemented as adapters (FastAPI, Django, Flask, DRF, Starlette/Litestar). This separation keeps the core framework\u2011agnostic.</li> <li>Ports/Interfaces: Core depends on abstract ports (sync/async-friendly; e.g., <code>RoleResolver</code>, <code>DecisionLogSink</code>, <code>MetricsSink</code>, <code>ObligationChecker</code>) enabling custom implementations without modifying the core.</li> <li>Security defaults: The default combining algorithm is <code>deny-overrides</code> (deny-by-default). Other algorithms: <code>permit-overrides</code>, <code>first-applicable</code>.</li> </ul>"},{"location":"highlights/#policy-model-json","title":"Policy Model (JSON)","text":"<ul> <li>Entities: <code>Subject</code>, <code>Resource</code>, <code>Action</code>, plus optional context.</li> <li>Rules &amp; Effects: Each rule defines conditions and an <code>effect</code> (Permit/Deny).</li> <li>Combining algorithms: <code>deny-overrides</code> (default), <code>permit-overrides</code>, <code>first-applicable</code>.</li> <li>Conditions: comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, etc.), collection operations (<code>hasAny</code>, <code>hasAll</code>), membership (<code>in</code>, <code>contains</code>), and time operators (<code>before</code>, <code>after</code>, <code>between</code>).</li> <li>Obligations: actions to perform on Permit decisions (e.g., require MFA, log an event).</li> </ul>"},{"location":"highlights/#integration","title":"Integration","text":"<ul> <li>Frameworks: Adapters for FastAPI, Flask, Django (incl. DRF), Starlette/Litestar.</li> <li>Enforcement: Dependencies/middleware/decorators (e.g., <code>rbacx.adapters.fastapi.require_access</code>) to guard endpoints, views, or request pipelines.</li> <li>Role Resolution: Pluggable role resolvers (e.g., static role inheritance with <code>StaticRoleResolver</code>).</li> </ul>"},{"location":"highlights/#policy-loading-reloading","title":"Policy Loading &amp; Reloading","text":"<ul> <li>Sources: Filesystem, HTTP(S), AWS S3.</li> </ul>"},{"location":"highlights/#observability-tooling","title":"Observability &amp; Tooling","text":"<ul> <li>Decision Introspection: Decision objects expose fields such as <code>allowed</code>, <code>effect</code>, <code>reason</code>, <code>rule_id</code>, enabling audit and explainability.</li> <li>Metrics &amp; Logging: Sinks for Prometheus / OpenTelemetry and structured logging are pluggable via ports.</li> <li>Linting: Policy linter/CLI to validate policy consistency before/at runtime.</li> </ul>"},{"location":"highlights/#testing","title":"Testing","text":"<ul> <li>Coverage: Meets industry standards. Approximately 80+% of the codebase.</li> <li>Scope: Tests cover decision logic, rule combining, ABAC operators (including time and collection ops), obligations, policy loading/reloading, and linting.</li> </ul>"},{"location":"highlights/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Internal indexing/compilation of policies to quickly skip irrelevant rules (e.g., by resource type).</li> <li>Stateless <code>Guard</code> suitable for horizontal scaling; shared policy sources (e.g., S3/file) can be used across instances.</li> <li>Documentation includes guidance on avoiding overly broad conditions and caching expensive context computations.</li> </ul>"},{"location":"highlights/#compatibility","title":"Compatibility","text":"<ul> <li>Python: see project metadata (pyproject.toml).</li> <li>Frameworks: FastAPI, Flask, Django/DRF, Starlette/Litestar (via adapters).</li> </ul>"},{"location":"highlights/#async-support","title":"Async support","text":"<ul> <li><code>Guard</code> provides both <code>evaluate_sync(...)</code> and <code>evaluate_async(...)</code>. Injected ports (resolver, obligations, metrics, logger) can be synchronous or asynchronous; both forms are supported.</li> <li><code>HotReloader</code> provides <code>check_and_reload(...)</code> (sync) and <code>check_and_reload_async(...)</code> (async) and accepts <code>PolicySource</code> implementations with sync or async <code>load()</code>/<code>etag()</code>.</li> </ul>"},{"location":"http_mapping/","title":"Mapping Decision reasons to HTTP responses","text":"<p>A common mapping when using RBACX in web apps:</p> Decision / reason HTTP code Notes <code>permit</code> 200/204 Proceed <code>explicit_deny</code> 403 Hard deny <code>no_match</code> / <code>no_match_policy</code> 403 Deny-by-default <code>condition_mismatch</code> 403 Policy matched but condition evaluated to False <code>condition_type_mismatch</code> 500 Authoring/data issue; investigate <code>obligation_failed</code> 403 (or 401 if an auth challenge) Permit was gated by obligations (e.g., MFA) and they were not fulfilled or failed verification. If the decision includes a <code>challenge</code> tied to authentication, you MAY return 401 and include the appropriate challenge header; otherwise return 403. <code>action_mismatch</code> 403 Rule exists but does not cover the action <code>resource_mismatch</code> 404/403 Prefer 404 for resource hiding; otherwise 403 <p>See OWASP guidance on logging and monitoring for how to record failures without leaking sensitive info.</p>"},{"location":"logging/","title":"Logging configuration","text":"<p>RBACX uses Python's standard <code>logging</code> and does not configure handlers for you.</p>"},{"location":"logging/#console-logging-dictconfig","title":"Console logging (dictConfig)","text":"<pre><code>import logging.config\nLOGGING = {\n  \"version\": 1,\n  \"disable_existing_loggers\": False,\n  \"formatters\": {\"console\": {\"format\": \"%(asctime)s %(levelname)s %(name)s: %(message)s\"}},\n  \"handlers\": {\"console\": {\"class\": \"logging.StreamHandler\", \"formatter\": \"console\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre>"},{"location":"logging/#rotating-file-logs","title":"Rotating file logs","text":"<pre><code>import logging.config\nLOGGING = {\n  \"version\": 1, \"disable_existing_loggers\": False,\n  \"formatters\": {\"plain\": {\"format\": \"%(asctime)s %(levelname)s %(name)s: %(message)s\"}},\n  \"handlers\": {\"file\": {\"class\": \"logging.handlers.RotatingFileHandler\", \"filename\": \"app.log\", \"maxBytes\": 5_000_000, \"backupCount\": 3, \"encoding\": \"utf-8\", \"formatter\": \"plain\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"file\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre>"},{"location":"logging/#json-logs-python-json-logger","title":"JSON logs (python-json-logger)","text":"<p><pre><code>pip install \"rbacx[jsonlog]\"\n</code></pre> <pre><code>import logging.config\nLOGGING = {\n  \"version\": 1, \"disable_existing_loggers\": False,\n  \"formatters\": {\"json\": {\"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\", \"format\": \"%(asctime)s %(levelname)s %(name)s %(message)s %(trace_id)s\"}},\n  \"handlers\": {\"console\": {\"class\": \"logging.StreamHandler\", \"formatter\": \"json\"}},\n  \"root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n}\nlogging.config.dictConfig(LOGGING)\n</code></pre></p>"},{"location":"logging/#request-tracing-trace_id","title":"Request tracing (trace_id)","text":"<p>Use <code>rbacx.logging.context.TraceIdFilter</code> to inject <code>trace_id</code> into records. - ASGI (FastAPI, Litestar): <code>rbacx.adapters.asgi_logging.TraceIdMiddleware</code>. - Django: <code>rbacx.adapters.django.trace.TraceIdMiddleware</code>. - Flask: hooks in the example manage <code>X-Request-ID</code> header.</p>"},{"location":"logging/#rbacx-decision-logger-audit-sink","title":"RBACX Decision Logger (audit sink)","text":"<p><code>rbacx.logging.decision_logger.DecisionLogger</code> implements the <code>DecisionLogSink</code> port. It can emit decision events either as text or JSON and supports sampling and redactions.</p> <p>Options: - <code>sample_rate: float</code> \u2014 probability in [0..1] to log the event. - <code>redactions: list[dict]</code> \u2014 obligations-style redactions applied to <code>env</code> before logging. - <code>as_json: bool</code> \u2014 when <code>True</code>, serialize the event to JSON; otherwise logs as <code>\"decision {payload}\"</code>. - <code>level: int</code> \u2014 Python logging level used for the event (defaults to <code>logging.INFO</code>).</p> <p>Example: <pre><code>import logging\nfrom rbacx.logging.decision_logger import DecisionLogger\n\naudit = logging.getLogger(\"rbacx.audit\")\naudit.setLevel(logging.INFO)\naudit.addHandler(logging.StreamHandler())\n\nlogger_sink = DecisionLogger(sample_rate=1.0, as_json=True, level=logging.INFO)\n</code></pre></p>"},{"location":"metrics/","title":"Metrics integration","text":"<p>RBACX can emit metrics via Prometheus or OpenTelemetry.</p>"},{"location":"metrics/#prometheus","title":"Prometheus","text":"<p>Use <code>PrometheusMetrics</code> sink (requires <code>prometheus_client</code>). Exposes: - <code>rbacx_decisions_total{allowed,reason}</code> \u2014 counter of decisions. - <code>rbacx_decision_duration_seconds</code> \u2014 histogram (adapters can observe latency).</p>"},{"location":"metrics/#opentelemetry","title":"OpenTelemetry","text":"<p>Use <code>OpenTelemetryMetrics</code> (requires <code>opentelemetry-api</code>). Creates instruments: - Counter <code>rbacx.decisions</code> (attributes: <code>allowed</code>, <code>reason</code>). - Histogram <code>rbacx.decision.duration.ms</code>.</p> <p>See OpenTelemetry Metrics API and Prometheus client docs for details. </p>"},{"location":"migration_rbac_to_abac/","title":"Migrating from RBAC to ABAC","text":"<p>This guide outlines pragmatic steps to evolve from role-based access control (RBAC) to attribute-based access control (ABAC).</p>"},{"location":"migration_rbac_to_abac/#1-inventory-roles-permissions","title":"1) Inventory roles &amp; permissions","text":"<p>Export your current RBAC roles and permissions; identify hotspots (over-privileged roles, cross-cutting exceptions).</p>"},{"location":"migration_rbac_to_abac/#2-identify-key-attributes","title":"2) Identify key attributes","text":"<p>Subject attributes (department, clearance), resource attributes (owner, tenant, classification), and environmental (time, geo). See NIST SP 800-162 for ABAC components and considerations.</p>"},{"location":"migration_rbac_to_abac/#3-start-with-deny-by-default","title":"3) Start with deny-by-default","text":"<p>Adopt <code>deny-overrides</code> and add explicit permits. Keep policies small and typed (resource.type).</p>"},{"location":"migration_rbac_to_abac/#4-express-exceptions-as-attributes","title":"4) Express exceptions as attributes","text":"<p>Turn ad-hoc role exceptions into ABAC rules (e.g., owner-based access). Prefer small, composable conditions.</p>"},{"location":"migration_rbac_to_abac/#5-dual-run-with-audit-mode","title":"5) Dual-run with audit-mode","text":"<p>Run PDP in audit mode alongside enforcement; compare <code>Decision.reason</code> and logs to detect gaps before enforcing.</p>"},{"location":"migration_rbac_to_abac/#6-decompose-roles","title":"6) Decompose roles","text":"<p>Gradually replace monolithic roles by attributes; maintain role hierarchy if needed (resolver) while transitioning.</p>"},{"location":"migration_rbac_to_abac/#7-validate-lint","title":"7) Validate &amp; lint","text":"<p>Use JSON Schema validation and <code>rbacx lint</code> to catch issues (broad rules, unreachable rules, duplicates).</p>"},{"location":"migration_rbac_to_abac/#8-educate-and-document","title":"8) Educate and document","text":"<p>Keep a policy authoring playbook and examples; require unique rule IDs and reasons in reviews.</p> <p>References: - NIST SP 800-162 ABAC (definition, components, considerations) - ANSI/INCITS 359-2004 RBAC (roles, permissions, hierarchies) - XACML 3.0 combining algorithms (deny-/permit-overrides, first-applicable)</p>"},{"location":"observability_stack/","title":"Observability (Prometheus + Grafana) via Docker Compose","text":"<p>A ready-to-run stack lives in <code>deploy/compose</code>: - <code>app</code> \u2013 FastAPI demo exposing <code>/metrics</code> using <code>prometheus_client.generate_latest()</code> - <code>prometheus</code> \u2013 scrapes <code>app:8000/metrics</code> - <code>grafana</code> \u2013 UI at <code>http://localhost:3000</code> (admin/admin by default)</p> <pre><code>docker compose -f deploy/compose/docker-compose.yml up --build\nopen http://localhost:8000/docs\nopen http://localhost:9090\nopen http://localhost:3000\n</code></pre> <p>Prometheus best practices: prefer Histograms for latency, choose buckets thoughtfully; when changing buckets, use a new metric name and keep the old during the transition to preserve history.</p>"},{"location":"otel_metrics/","title":"OpenTelemetry metrics","text":"<p>Install <code>rbacx[otel]</code> and wire <code>OTelMetrics</code>:</p> <pre><code>from rbacx import Guard\n\nfrom rbacx.metrics.otel import OpenTelemetryMetrics\nmetrics = OpenTelemetryMetrics(meter_name=\"rbacx\")\npolicy = {\"rules\": [{\"effect\": \"permit\"}]}\nguard = Guard(policy, metrics=metrics)\n</code></pre> <p>The sink records <code>rbacx_decision_total</code> counter with attributes: <code>allowed</code>, <code>reason</code>. See OpenTelemetry metrics API spec for creating counters and histograms.</p>"},{"location":"performance/","title":"Performance","text":"<ul> <li>Keep rules specific (avoid global <code>\"*\"</code> when possible).</li> <li>Cache expensive context derivations outside of Guard calls.</li> <li>Prefer JSON logging to reduce formatting overhead in hot paths.</li> <li>Scale horizontally: stateless <code>Guard</code> + shared policy source (file/HTTP/S3).</li> </ul>"},{"location":"policy_authoring/","title":"Policy authoring guide","text":"<p>This guide outlines how to write clear and maintainable RBAC/ABAC policies.</p>"},{"location":"policy_authoring/#core-concepts","title":"Core concepts","text":"<ul> <li>RBAC \u2013 users get roles, roles carry permissions. Keep roles stable, map users to roles dynamically.</li> <li>ABAC \u2013 decisions come from evaluating attributes of subject, resource, action, and environment against rules.</li> <li>Combining algorithms \u2013 <code>deny-overrides</code>, <code>permit-overrides</code>, <code>first-applicable</code>. Choose the one that matches your risk posture.</li> </ul>"},{"location":"policy_authoring/#recommendations","title":"Recommendations","text":"<ul> <li>Start with deny-by-default (<code>deny-overrides</code>) and add explicit permits.</li> <li>Prefer simple conditions; avoid hidden coercions \u2013 types must match.</li> <li>Keep resources typed (e.g., <code>doc</code>, <code>invoice</code>) and avoid broad <code>*</code> unless required.</li> <li>Name every rule with unique id and tag high-risk rules with <code>obligations</code> (e.g., <code>mfa</code>).</li> <li>Validate policies with JSON Schema before loading.</li> <li>Document ownership and review cadence for policy files.</li> </ul>"},{"location":"policy_authoring/#examples","title":"Examples","text":""},{"location":"policy_authoring/#permit-with-mfa-requirement","title":"Permit with MFA requirement","text":"<pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\": [\n    {\n      \"id\": \"doc_read\",\n      \"effect\": \"permit\",\n      \"actions\": [\"read\"],\n      \"resource\": { \"type\": \"doc\" },\n      \"condition\": { \"==\": [ {\"attr\":\"context.mfa\"}, true ] },\n      \"obligations\": [{\"type\":\"require_mfa\"}]\n    }\n  ]\n}\n</code></pre>"},{"location":"policy_authoring/#first-applicable","title":"First-applicable","text":"<p>Stops on the first matched permit/deny, useful for ordered policies.</p>"},{"location":"policy_authoring/#yaml-example","title":"YAML example","text":"<pre><code>algorithm: permit-overrides\nrules:\n  - id: p1\n    effect: permit\n    actions: [read]\n    resource: { type: doc }\n    condition:\n      hasAny:\n        - attr: subject.roles\n        - [user, viewer]\n  - id: d1\n    effect: deny\n    actions: [delete]\n    resource: { type: doc }\n</code></pre>"},{"location":"policy_catalog/","title":"Policy Catalog (RBAC &amp; ABAC patterns)","text":""},{"location":"policy_catalog/#tenant-isolation-resourceownertenant","title":"Tenant isolation (resource.owner/tenant)","text":"<pre><code>{\n  \"algorithm\": \"deny-overrides\",\n  \"rules\": [\n    {\"id\":\"tenant_read\",\"effect\":\"permit\",\"actions\":[\"read\"],\"resource\":{\"type\":\"doc\"},\n     \"condition\":{\"==\":[{\"attr\":\"subject.tenant\"},{\"attr\":\"resource.attrs.tenant\"}]}},\n    {\"id\":\"tenant_write\",\"effect\":\"permit\",\"actions\":[\"write\"],\"resource\":{\"type\":\"doc\"},\n     \"condition\":{\"==\":[{\"attr\":\"subject.tenant\"},{\"attr\":\"resource.attrs.tenant\"}]}}\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#owner-only","title":"Owner-only","text":"<pre><code>{\n  \"rules\":[\n    {\"id\":\"owner\",\"effect\":\"permit\",\"actions\":[\"*\"],\"resource\":{\"type\":\"doc\"},\n     \"condition\":{\"==\":[{\"attr\":\"subject.id\"},{\"attr\":\"resource.attrs.owner\"}]}}\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#clearance-classification-numbers","title":"Clearance &gt;= classification (numbers)","text":"<pre><code>{\n  \"rules\":[\n    {\"id\":\"clearance\",\"effect\":\"permit\",\"actions\":[\"read\"],\"resource\":{\"type\":\"record\"},\n     \"condition\":{\"&gt;=\":[{\"attr\":\"subject.clearance\"},{\"attr\":\"resource.attrs.classification\"}]}}\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#time-window-business-hours-mfa-obligation","title":"Time window (business hours) + MFA obligation","text":"<pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\":[\n    {\"id\":\"work_hours\",\"effect\":\"permit\",\"actions\":[\"read\"],\"resource\":{\"type\":\"doc\"},\n     \"condition\":{\"between\":[{\"attr\":\"context.now\"}, [\"2025-01-01T08:00:00Z\",\"2025-01-01T18:00:00Z\"]]}},\n    {\"id\":\"mfa\",\"effect\":\"permit\",\"actions\":[\"read\"],\"resource\":{\"type\":\"doc\"},\n     \"condition\":{\"==\":[{\"attr\":\"context.mfa\"}, true]},\n     \"obligations\":[{\"type\":\"require_mfa\"}]}\n  ]\n}\n</code></pre>"},{"location":"policy_catalog/#segmented-deletes-id-allow-list","title":"Segmented deletes (id allow-list)","text":"<pre><code>{\n  \"rules\":[\n    {\"id\":\"delete_whitelist\",\"effect\":\"permit\",\"actions\":[\"delete\"],\"resource\":{\"type\":\"doc\",\"id\":\"A\"}},\n    {\"id\":\"no_delete_others\",\"effect\":\"deny\",\"actions\":[\"delete\"],\"resource\":{\"type\":\"doc\"}}\n  ]\n}\n</code></pre>"},{"location":"policy_loading/","title":"Policy loading (hot reload)","text":"<p>RBACX supports hot-reloading policies from external sources via a production-grade reloader.</p> <ul> <li>A policy source implements the <code>PolicySource</code> protocol (sync or async):   <code>load() -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]</code> and <code>etag() -&gt; Optional[str] | Awaitable[Optional[str]]</code>.</li> <li>The <code>HotReloader</code> watches a source: when its ETag changes, it loads the new policy and applies it to a running <code>Guard</code>. (If <code>etag()</code> returns <code>None</code>, the reloader will attempt a load and let the source decide change detection.) ETag is a standard content version identifier in HTTP and storage systems.</li> </ul>"},{"location":"policy_loading/#when-to-use","title":"When to use","text":"<ul> <li>You want changes to JSON or dict policies to be picked up without restarting your application.</li> <li>You use file/HTTP/S3 (or any custom) policy storage and want automatic or manual checks for updates.</li> <li>You want resilient reloads with exponential backoff + jitter after errors to avoid thundering herds.</li> </ul>"},{"location":"policy_loading/#quick-examples","title":"Quick examples","text":""},{"location":"policy_loading/#1-safe-startup-recommended","title":"1) Safe startup (recommended)","text":"<p>Ensures a valid policy is loaded at boot, then enables background polling.</p> <pre><code>from rbacx import Guard\nfrom rbacx.store import FilePolicySource\nfrom rbacx import HotReloader\n\nguard = Guard(policy={})\nsource = FilePolicySource(\"policy.json\")\n\nreloader = HotReloader(guard, source, initial_load=True, poll_interval=2.0)\n\n# Synchronously load whatever is in policy.json right now\nreloader.check_and_reload()        # returns True on first load\n\n# Then keep watching for changes in the background\nreloader.start()\n# ...\nreloader.stop()\n</code></pre>"},{"location":"policy_loading/#2-legacy-behavior-no-initial-load","title":"2) Legacy behavior (no initial load)","text":"<p>First check is a NO-OP unless the policy changes (backwards-compatible default).</p> <pre><code>reloader = HotReloader(guard, source, initial_load=False)\nreloader.check_and_reload()        # likely False until ETag changes\n</code></pre>"},{"location":"policy_loading/#3-force-a-one-time-load-ignore-etag","title":"3) Force a one-time load (ignore ETag)","text":"<p>Useful for bootstrap/migrations.</p> <pre><code>reloader = HotReloader(guard, source)\nreloader.check_and_reload(force=True)\n</code></pre>"},{"location":"policy_loading/#4-force-initial-load-via-start","title":"4) Force initial load via <code>start()</code>","text":"<p>Performs a synchronous load before the thread starts.</p> <pre><code>reloader = HotReloader(guard, source, initial_load=False)\nreloader.start(initial_load=True, force_initial=True)\n</code></pre> <p>Steps: 1) Start with an initial or empty policy 2) Choose source (Local filesystem in examples) 3) Create the reloader (optionally enable <code>initial_load</code>) 4) Optional: force a one-time check at startup 5) Optional: run background polling 6) Your app runs between <code>start()</code> and <code>stop()</code></p>"},{"location":"policy_loading/#hotreloader-api","title":"HotReloader API","text":"<pre><code>from rbacx import HotReloader\n</code></pre>"},{"location":"policy_loading/#constructor-parameters","title":"Constructor parameters","text":"Parameter Description <code>guard</code> The <code>rbacx.core.engine.Guard</code> instance to update. <code>source</code> Any <code>PolicySource</code> (File, HTTP, S3, custom, \u2026). <code>initial_load: bool = False</code> If <code>True</code>, do not prime the ETag so the first <code>check_and_reload()</code> will load the current policy. If <code>False</code> (default), the first check is a NO-OP unless the ETag changed (legacy behavior). <code>poll_interval: float = 5.0</code> Default polling interval (seconds) used by <code>start()</code>."},{"location":"policy_loading/#methods","title":"Methods","text":"<ul> <li> <p><code>check_and_reload(*, force: bool = False) -&gt; bool</code>   Synchronously checks the source\u2019s ETag; if changed, loads and applies the policy.   If <code>force=True</code>, loads and applies regardless of ETag. Returns <code>True</code> if a reload occurred.</p> </li> <li> <p><code>start(interval: float | None = None, *, initial_load: bool | None = None, force_initial: bool = False) -&gt; None</code>   Starts background polling.</p> </li> <li><code>interval</code> overrides the constructor\u2019s <code>poll_interval</code>.</li> <li><code>initial_load</code> overrides the constructor\u2019s flag just for this start.</li> <li> <p>If <code>initial_load</code> is truthy and <code>force_initial=True</code>, performs a synchronous load before starting the thread (ETag ignored for that initial load).</p> </li> <li> <p><code>stop(timeout: float | None = None) -&gt; None</code>   Stops background polling; optionally waits up to <code>timeout</code> seconds for the current check.</p> </li> </ul>"},{"location":"policy_loading/#diagnostics-properties","title":"Diagnostics / properties","text":"<ul> <li><code>last_etag</code> \u2014 most recently seen ETag from the source.</li> <li><code>last_reload_at</code> \u2014 timestamp of the last successful reload.</li> <li><code>last_error</code> \u2014 the last exception encountered (if any).</li> <li><code>suppressed_until</code> \u2014 time until which further attempts are delayed after errors (exponential backoff with jitter).</li> </ul>"},{"location":"policy_loading/#typical-reload-cycle","title":"Typical reload cycle","text":"<ol> <li>Ask the <code>PolicySource</code> for its current ETag.</li> <li>If the ETag is new (or <code>etag()</code> is <code>None</code>), call <code>load()</code> to fetch the policy.</li> <li>Validate (if the source performs schema checks).</li> <li>Apply the policy to <code>guard</code> only after a successful load.</li> <li>On errors (parse, network, permissions), keep the previous working policy, log the error, and schedule the next attempt using exponential backoff with jitter.</li> </ol>"},{"location":"policy_loading/#integration-with-web-frameworks","title":"Integration with web frameworks","text":""},{"location":"policy_loading/#asgi-middleware-on-request-checks","title":"ASGI middleware &amp; on-request checks","text":"<p>Use <code>HotReloader</code> with your middleware to check for changes before handling requests, or rely solely on background polling.</p> <pre><code>from rbacx.adapters.asgi import RbacxMiddleware\nfrom rbacx import Guard\nfrom rbacx.store import FilePolicySource\nfrom rbacx import HotReloader\nfrom litestar import Litestar, get\nfrom litestar.middleware import DefineMiddleware\n\nguard = Guard(policy={})\nreloader = HotReloader(guard, FilePolicySource(\"policy.json\"), initial_load=True, poll_interval=2.0)\nreloader.check_and_reload()  # ensure policy is present at startup\n\n@get(\"/secure\")\ndef secure() -&gt; dict:\n    # guard used automatically via middleware or dependency\n    return {\"ok\": True}\n\napp = Litestar(\n    route_handlers=[secure],\n    middleware=[DefineMiddleware(RbacxMiddleware, guard=guard, policy_reloader=reloader)],\n)\n</code></pre> <p>If you need ultra-low detection latency, call <code>reloader.check_and_reload()</code> at the beginning of request handling (cheap ETag check), or keep background polling short.</p>"},{"location":"policy_loading/#supported-policysource-types","title":"Supported <code>PolicySource</code> types","text":"<p>Out of the box, RBACX provides:</p> <ul> <li>FilePolicySource \u2014 local JSON file or dict snapshot.</li> <li>HTTPPolicySource \u2014 HTTP/HTTPS endpoint (ideal with ETag or Last-Modified validators).</li> <li>S3PolicySource \u2014 Amazon S3 objects with ETag-based change detection.</li> </ul> <p>Any custom source that implements <code>load()</code> and <code>etag()</code> is supported.</p>"},{"location":"policy_loading/#operational-guidance","title":"Operational guidance","text":"<ul> <li>Atomic writes (file sources): write to a temp file and <code>rename</code> to avoid readers seeing partial content.</li> <li>Backoff &amp; jitter: on repeated failures, use exponential backoff with jitter; this avoids synchronized retries and thundering herds. RBACX\u2019s reloader applies jitter by default.</li> <li>Observability: export metrics/counters for reload successes/failures and <code>last_reload_at</code>.</li> <li>Fail-safe policy: keep the last known good policy if a new load fails.</li> <li>Security defaults: default-deny policies are recommended until the first valid policy is loaded.</li> </ul>"},{"location":"policy_loading/#sync-vs-async-usage","title":"Sync vs Async usage","text":"<p><code>HotReloader</code> exposes both a synchronous and an asynchronous API:</p> <ul> <li><code>check_and_reload(...)</code> \u2014 sync wrapper over the async core. Safe to call in synchronous apps (Flask/CLI) and even inside a running event loop; the reloader will delegate work to a helper thread.</li> <li><code>check_and_reload_async(...)</code> \u2014 async-native method for ASGI/async tasks.</li> </ul> <p>Examples:</p> <p>Sync (Flask/CLI/Celery)</p> <pre><code>reloader = HotReloader(guard, source)\nchanged = reloader.check_and_reload()\n</code></pre> <p>Async (FastAPI background task / asyncio)</p> <pre><code>reloader = HotReloader(guard, source)\nchanged = await reloader.check_and_reload_async()\n</code></pre>"},{"location":"policy_loading/#deprecated-api","title":"Deprecated API","text":"<ul> <li><code>ReloadingPolicyManager</code> is deprecated and kept only for compatibility. Constructing it emits a <code>DeprecationWarning</code> and a log warning; it delegates to <code>HotReloader</code> with legacy semantics (<code>initial_load=False</code>). Please migrate to <code>HotReloader</code>.</li> <li><code>PolicyManager</code> from <code>rbacx.store.manager</code> is deprecated; use <code>HotReloader</code> (plus a <code>PolicySource</code> such as <code>FilePolicySource</code>) instead.</li> </ul>"},{"location":"policy_loading/#changelog-excerpt","title":"Changelog (excerpt)","text":"<ul> <li><code>HotReloader(..., initial_load: bool = False)</code> \u2014 new flag to control startup behavior.</li> <li><code>check_and_reload(force: bool = False)</code> \u2014 new <code>force</code> parameter to bypass ETag.</li> <li><code>start(..., initial_load: bool | None = None, force_initial: bool = False)</code> \u2014 optional synchronous load before the polling thread starts.</li> <li><code>ReloadingPolicyManager</code> and <code>rbacx.store.manager.PolicyManager</code> \u2014 deprecated; use <code>HotReloader</code>.</li> </ul>"},{"location":"policy_stores/","title":"Policy stores","text":"<p>Policy sources implement a single protocol:</p> <pre><code>from typing import Any, Dict, Optional, Protocol, Awaitable\n\nclass PolicySource(Protocol):\n    def load(self) -&gt; Dict[str, Any] | Awaitable[Dict[str, Any]]: ...\n    def etag(self) -&gt; Optional[str] | Awaitable[Optional[str]]: ...\n</code></pre> <p>Out of the box, three stores are available: File, HTTP, S3.</p>"},{"location":"policy_stores/#filepolicysource-local-file","title":"FilePolicySource (local file)","text":"<p>Module: <code>rbacx.store.file_store</code> (also re-exported from <code>rbacx.store</code>).</p>"},{"location":"policy_stores/#import-basic-usage","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store import FilePolicySource\n\nsource = FilePolicySource(\"policy.json\")  # path to a JSON file\ndoc = source.load()                       # policy as a dict\ntag = source.etag()                       # string or None\n</code></pre>"},{"location":"policy_stores/#behavior","title":"Behavior","text":"<ul> <li>Loads JSON from a local file.</li> <li><code>etag()</code> reflects the file content (suitable for change detection).</li> <li>If validation is enabled, it performs a schema check via <code>rbacx.dsl.validate</code>.</li> </ul>"},{"location":"policy_stores/#constructor-options-core","title":"Constructor options (core)","text":"<ul> <li><code>validate_schema: bool = False</code> \u2014 enable schema validation on <code>load()</code>.</li> <li><code>include_mtime_in_etag: bool</code> - if needed \"touch\" changes detected (default <code>False</code>).</li> </ul>"},{"location":"policy_stores/#safe-write-utility","title":"Safe write utility","text":"<pre><code>from rbacx.store import atomic_write\n\natomic_write(\"policy.json\", data='{\"rules\": []}', encoding=\"utf-8\")\n</code></pre>"},{"location":"policy_stores/#httppolicysource-httphttps","title":"HTTPPolicySource (HTTP/HTTPS)","text":"<p>Module: <code>rbacx.store.http_store</code>. Extra dependency: <code>pip install \"rbacx[http]\"</code>.</p>"},{"location":"policy_stores/#import-basic-usage_1","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store.http_store import HTTPPolicySource  # also re-exported from `rbacx.store`.\n\nsource = HTTPPolicySource(\"https://example.com/rbac/policy.json\")\ndoc = source.load()   # dict; if server returns 304 Not Modified \u2014 returns {}\ntag = source.etag()   # last ETag (if provided by the server)\n</code></pre>"},{"location":"policy_stores/#behavior_1","title":"Behavior","text":"<ul> <li>Issues a GET request and, if a previous ETag is known, sends <code>If-None-Match</code>.</li> <li>On <code>304 Not Modified</code>, returns empty dict <code>{}</code> \u2014 a signal that applying can be skipped.</li> </ul>"},{"location":"policy_stores/#constructor-options-core_1","title":"Constructor options (core)","text":"<ul> <li><code>headers: dict[str, str] | None = None</code> \u2014 additional HTTP headers.</li> </ul>"},{"location":"policy_stores/#s3policysource","title":"S3PolicySource","text":"<p>Module: <code>rbacx.store.s3_store</code> (also re-exported from <code>rbacx.store</code>). Requires: <code>boto3</code> (and optionally <code>botocore</code> for advanced client tuning).</p>"},{"location":"policy_stores/#import-basic-usage_2","title":"Import &amp; basic usage","text":"<pre><code>from rbacx.store import S3PolicySource\n\nsource = S3PolicySource(\"s3://my-bucket/policies/rbac.json\")\ndoc = source.load()   # JSON document from S3 as a dict\ntag = source.etag()   # string or None (depending on the strategy)\n</code></pre>"},{"location":"policy_stores/#change-detection-strategies","title":"Change-detection strategies","text":"<p>The <code>change_detector</code> parameter selects the source of the \"change tag\":</p> <ul> <li><code>\"etag\"</code> (default) \u2014 uses ETag from <code>HeadObject</code>.</li> <li><code>\"version_id\"</code> \u2014 uses <code>VersionId</code> (bucket versioning must be enabled).</li> <li><code>\"checksum\"</code> \u2014 uses <code>GetObjectAttributes(..., ObjectAttributes=['Checksum'])</code> if object checksums are enabled.</li> </ul> <p>If a strategy is unavailable for a particular bucket/object, use <code>\"etag\"</code> (the most compatible option).</p>"},{"location":"policy_stores/#options-core","title":"Options (core)","text":"<ul> <li><code>validate_schema: bool = False</code> \u2014 validate the policy against the schema on <code>load()</code>.</li> </ul> <p>Network/client parameters:</p> <ul> <li>You can pass a prepared <code>boto3.Session</code>.</li> <li>Timeouts/retries can be tuned via <code>botocore.config.Config</code>.</li> <li>Additional client parameters are accepted (e.g., <code>endpoint_url</code>, <code>region_name</code>).</li> </ul> <p>(Argument names match the <code>S3PolicySource</code> constructor; use the simple form from the example if you don't need advanced tuning.)</p>"},{"location":"policy_stores/#using-with-hotreloader","title":"Using with HotReloader","text":"<p>Any store can be connected to <code>HotReloader</code>:</p> <pre><code>from rbacx import Guard\nfrom rbacx import HotReloader\nfrom rbacx.store import FilePolicySource, S3PolicySource\nfrom rbacx.store.http_store import HTTPPolicySource\n\nguard = Guard(policy={})\n\n# Local file\nfile_src = FilePolicySource(\"policy.json\")\nHotReloader(guard, file_src, poll_interval=2.0).start()\n\n# HTTP\nhttp_src = HTTPPolicySource(\"https://example.com/rbac/policy.json\")\nHotReloader(guard, http_src, poll_interval=5.0).start()\n\n# S3\ns3_src = S3PolicySource(\"s3://my-bucket/policies/rbac.json\")\nHotReloader(guard, s3_src, poll_interval=5.0).start()\n</code></pre> <p>It is recommended to begin with an explicit <code>check_and_reload()</code> when the process starts, and then either enable background polling with <code>start()</code> or call <code>check_and_reload()</code> at request boundaries (see <code>RbacxMiddleware</code>).</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This page shows how to install RBACX and its optional extras.</p> <p>RBACX keeps the core lightweight and avoids pulling heavy dependencies by default. This helps keep it framework\u2011agnostic and reduces conflicts in real projects. If you need integrations or helpers, install extras selectively.</p>"},{"location":"quickstart/#install","title":"Install","text":"<p>Minimal install:</p> <pre><code>pip install rbacx\n</code></pre>"},{"location":"quickstart/#optional-features-extras","title":"Optional features (extras)","text":"Extra Enables Install command <code>adapters-fastapi</code> FastAPI / Starlette adapters <code>pip install rbacx[adapters-fastapi]</code> <code>adapters-flask</code> Flask adapters <code>pip install rbacx[adapters-flask]</code> <code>adapters-drf</code> Django + DRF adapters <code>pip install rbacx[adapters-drf]</code> <code>adapters-litestar</code> Litestar adapters <code>pip install rbacx[adapters-litestar]</code> <code>metrics</code> Prometheus client metrics <code>pip install rbacx[metrics]</code> <code>otel</code> OpenTelemetry API/SDK helpers <code>pip install rbacx[otel]</code> <code>http</code> HTTP policy source (requests) <code>pip install rbacx[http]</code> <code>s3</code> S3 policy source (boto3) <code>pip install rbacx[s3]</code> <code>dates</code> Time operators support (python\u2011dateutil) <code>pip install rbacx[dates]</code> <code>yaml</code> YAML policies support <code>pip install rbacx[yaml]</code> <p>You can combine extras:</p> <pre><code>pip install 'rbacx[adapters-fastapi,metrics,otel]'\n</code></pre> <p>Why a separate YAML extra? YAML is optional. If you want to author policies in YAML, install <code>rbacx[yaml]</code>. YAML\u2019s official media type is <code>application/yaml</code> (see RFC 9512). For security, we parse YAML with <code>yaml.safe_load</code>. </p>"},{"location":"quickstart/#define-a-policy-json-or-yaml","title":"Define a policy (JSON or YAML)","text":"<p>Both JSON and YAML are supported. They\u2019re parsed into a <code>dict</code> and validated against the same JSON Schema.</p> <p>JSON:</p> <pre><code>{\n  \"algorithm\": \"permit-overrides\",\n  \"rules\": [\n    {\"id\": \"p1\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}},\n    {\"id\": \"d1\", \"effect\": \"deny\",   \"actions\": [\"delete\"], \"resource\": {\"type\": \"doc\"}}\n  ]\n}\n</code></pre> <p>YAML:</p> <pre><code>algorithm: permit-overrides\nrules:\n  - id: p1\n    effect: permit\n    actions: [read]\n    resource: { type: doc }\n  - id: d1\n    effect: deny\n    actions: [delete]\n    resource: { type: doc }\n</code></pre>"},{"location":"quickstart/#load-a-policy","title":"Load a policy","text":"<p>You can load policies from files, HTTP, or S3 or create your policy source.</p> <pre><code>from rbacx import Guard\nfrom rbacx.store.file_store import FilePolicySource\nfrom rbacx.store.http_store import HTTPPolicySource\nfrom rbacx.store.s3_store import S3PolicySource\n\nguard = Guard(policy=FilePolicySource(\"examples/policies/ok_policy.json\"))\n# guard = Guard(policy=FilePolicySource(\"examples/policies/ok_policy.yaml\"))  # requires rbacx[yaml]\n\n# HTTP: YAML detected by Content-Type (application/yaml) or URL suffix .yaml/.yml\n# guard = Guard(policy=HTTPPolicySource(\"https://example.com/policy.yaml\"))\n\n# S3: YAML detected by key suffix .yaml/.yml\n# guard = Guard(policy=S3PolicySource(\"s3://my-bucket/policy.yaml\"))\n</code></pre>"},{"location":"quickstart/#cli","title":"CLI","text":"<p>Lint a policy file (JSON or YAML):</p> <pre><code>rbacx lint --policy examples/policies/ok_policy.json\nrbacx lint --policy examples/policies/ok_policy.yaml\nrbacx lint --policy examples/policies/bad_policy.json\nrbacx lint --policy examples/policies/bad_policy.yaml\n</code></pre> <p>The CLI prints JSON diagnostics. A non-empty list means warnings/errors were found.</p> <p>Need more? See the full docs site for adapters, middleware, metrics, and advanced configuration.</p>"},{"location":"reasons/","title":"Decision reasons","text":"Reason Meaning <code>matched</code> A permit rule matched <code>explicit_deny</code> A deny rule matched <code>condition_mismatch</code> Condition evaluated to False <code>condition_type_mismatch</code> Incompatible types in a condition <code>resource_mismatch</code> Resource type/id/attrs didn't match <code>action_mismatch</code> Action not in rule's action list <code>no_match</code> No rule matched <code>obligation_failed</code> Obligations required by a permit rule were not met or failed verification (e.g., MFA) <p>Operators include: <code>hasAll</code>, <code>hasAny</code>, <code>before/after/between</code>, plus standard comparisons.</p>"},{"location":"roles/","title":"Role hierarchy","text":"<p>Use <code>StaticRoleResolver</code> to expand roles with inheritance:</p> <pre><code>from rbacx.core.roles import StaticRoleResolver\nresolver = StaticRoleResolver({\"admin\":[\"manager\"], \"manager\":[\"employee\"]})\nexpanded = resolver.expand([\"admin\"])  # ['admin','employee','manager']\n</code></pre> <p>Wire into the <code>Guard</code>:</p> <pre><code>from rbacx import Guard\n\npolicy = {...}  # define yours here\nresolver = ...  # use resolver from above\n\nguard = Guard(policy, role_resolver=resolver)\n</code></pre> <p>The RBAC standard (ANSI/INCITS 359-2004) includes role hierarchies.</p>"},{"location":"security/","title":"Security","text":"<ul> <li>Validate policies (JSON Schema 2020-12) before applying.</li> <li>Avoid logging sensitive data; apply masking obligations to payloads.</li> <li>Reload policies atomically (HotReloader already re-computes etag).</li> <li>Consider step-up auth challenges (e.g., MFA) for high-risk actions.</li> </ul>"},{"location":"time_operators/","title":"Time operators","text":"<p>Operators: <code>before</code>, <code>after</code>, <code>between</code> using ISO-8601 strings (e.g., <code>2025-09-07T10:00:00Z</code>).</p> <ul> <li>Parser prefers <code>datetime.fromisoformat</code>, normalizing <code>Z</code> to <code>+00:00</code>.</li> <li>Falls back to <code>dateutil.isoparse</code> if <code>rbacx[dates]</code> installed.</li> </ul> <p>Examples: <pre><code>{\"before\": [ {\"attr\":\"context.now\"}, \"2025-12-31T23:59:59Z\" ]}\n{\"between\": [ {\"attr\":\"context.now\"}, [\"2025-01-01T00:00:00Z\",\"2025-12-31T23:59:59Z\"] ]}\n</code></pre></p>"},{"location":"try_examples/","title":"Running the examples (Django, DRF, FastAPI, Flask, Litestar)","text":"<p>This guide shows how to run all demo apps under <code>examples/</code>, exactly as implemented in the sources.</p> <ul> <li><code>examples/django_demo</code> \u2014 plain Django</li> <li><code>examples/drf_demo</code> \u2014 Django REST Framework</li> <li><code>examples/fastapi_demo</code> \u2014 FastAPI</li> <li><code>examples/flask_demo</code> \u2014 Flask</li> <li><code>examples/litestar_demo</code> \u2014 Litestar</li> </ul>"},{"location":"try_examples/#install-from-pypi-extras","title":"Install from PyPI (extras)","text":"<p>Install only what you need via extras from PyPI (no editable install):</p> <pre><code># choose one or more:\npip install rbacx[adapters-drf]\npip install rbacx[adapters-fastapi]\npip install rbacx[adapters-flask]\npip install rbacx[adapters-litestar]\n# or everything used by the examples:\npip install rbacx[examples]\n</code></pre> <p>Depending on your shell you may need quotes: <code>pip install \"rbacx[adapters-drf]\"</code>.</p>"},{"location":"try_examples/#django-examplesdjango_demo","title":"Django (<code>examples/django_demo</code>)","text":"<pre><code>python examples/django_demo/manage.py migrate\npython examples/django_demo/manage.py runserver 127.0.0.1:8000\n# Test:\ncurl -i http://127.0.0.1:8000/health\ncurl -i http://127.0.0.1:8000/doc\n</code></pre> <p>Endpoints - <code>GET /health</code> \u2192 <code>{\"ok\": true}</code> - <code>GET /doc</code> \u2192 JSON decision result:   - Allowed: <code>{ \"allowed\": true, \"docs\": [\"doc-1\", \"doc-2\"] }</code>   - Denied: <code>{ \"allowed\": false, \"reason\": \"...\" }</code> (HTTP 403)</p> <p>The demo uses a tiny in-repo guard (see <code>rbacx_demo/rbacx_factory.py</code>). The <code>docs</code> view normalizes a decision-like object and returns JSON accordingly.</p>"},{"location":"try_examples/#django-rest-framework-examplesdrf_demo","title":"Django REST Framework (<code>examples/drf_demo</code>)","text":"<pre><code>python examples/drf_demo/manage.py migrate\npython examples/drf_demo/manage.py runserver 127.0.0.1:8001\n# Test:\ncurl -i http://127.0.0.1:8001/docs\n</code></pre> <p>Endpoint - <code>GET /docs</code> \u2192 <code>{ \"ok\": true }</code> on success</p> <p>Access control is enforced with <code>rbacx.adapters.drf.make_permission(guard, build_env)</code>, see <code>docsapp/views.py</code>. The example policy in <code>docsapp/policy.json</code> permits <code>read</code> on resources of type <code>\"doc\"</code>.</p>"},{"location":"try_examples/#fastapi-examplesfastapi_demo","title":"FastAPI (<code>examples/fastapi_demo</code>)","text":"<pre><code>uvicorn examples.fastapi_demo.app:app --reload --port 8002\n# Test:\ncurl -i http://127.0.0.1:8002/ping\ncurl -i http://127.0.0.1:8002/doc\n</code></pre> <p>Endpoints - <code>GET /ping</code> \u2192 <code>{\"pong\": true}</code> - <code>GET /doc</code>  \u2192 <code>{\"ok\": true}</code> on success</p> <p>The dependency <code>require_access(guard, build_env, add_headers=True)</code> checks access before the handler. <code>build_env</code> reads <code>X-User</code> (optional) and constructs: <code>Subject(id, roles=[\"user\"])</code>, <code>Action(\"read\")</code>, <code>Resource(type=\"doc\")</code>, <code>Context()</code>.</p>"},{"location":"try_examples/#flask-examplesflask_demo","title":"Flask (<code>examples/flask_demo</code>)","text":"<pre><code>flask --app examples/flask_demo/app.py run --port 8003\n# Test:\ncurl -i http://127.0.0.1:8003/ping\ncurl -i http://127.0.0.1:8003/doc\n</code></pre> <p>Endpoints - <code>GET /ping</code> \u2192 <code>{\"pong\": true}</code> - <code>GET /doc</code> \u2192 protected by <code>@require_access(...)</code></p> <p><code>build_env</code> also reads the optional <code>X-User</code> header and sets roles to <code>[\"user\"]</code>.</p>"},{"location":"try_examples/#litestar-exampleslitestar_demo","title":"Litestar (<code>examples/litestar_demo</code>)","text":"<pre><code>uvicorn examples.litestar_demo.app:app --reload --port 8004\n# (optional structured logs)\n# uvicorn app:app --reload --port 8004 --log-config ../logging/uvicorn_logging_json.yml\n\n# Test:\ncurl -i http://127.0.0.1:8004/health\ncurl -i http://127.0.0.1:8004/docs/1\n</code></pre> <p>Endpoints - <code>GET /health</code> \u2192 <code>{\"ok\": true}</code> - <code>GET /docs/{doc_id}</code> \u2192 returns a JSON object with <code>{\"allowed\": &lt;bool&gt;}</code> computed by the guard, see <code>get_doc</code> handler. The resource type is <code>\"doc\"</code>.</p>"},{"location":"try_examples/#notes","title":"Notes","text":"<ul> <li>Authorization failures generally return 403 with a short JSON body. If your decision includes an authentication challenge (e.g., MFA required), returning 401 with an appropriate <code>WWW-Authenticate</code> or custom challenge header may be more appropriate. See Mapping Decision reasons to HTTP responses.</li> <li>Only the FastAPI and Flask demos read <code>X-User</code>; DRF uses <code>request.user</code>; Django demo uses a hard-coded demo subject with the <code>demo_user</code> role.</li> </ul>"},{"location":"try_examples/#yaml-policies","title":"YAML policies","text":"<p>You can also try YAML policies:</p> <pre><code>rbacx lint --policy examples/policies/ok_policy.yaml\nrbacx lint --policy examples/policies/bad_policy.yaml\n</code></pre>"},{"location":"web_adapters/","title":"Web framework adapters","text":"<p>RBACX ships simple adapters for popular frameworks.</p>"},{"location":"web_adapters/#fastapi-dependency","title":"FastAPI (dependency)","text":"<pre><code>from fastapi import FastAPI, Depends, Request\nfrom rbacx.adapters.fastapi import require_access\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": [\n    {\"id\": \"doc_read\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}}\n]}\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    user_id = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user_id, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = FastAPI()\n\n@app.get(\"/doc\", dependencies=[Depends(require_access(guard, build_env, add_headers=True))])\nasync def doc():\n    return {\"ok\": True}\n</code></pre>"},{"location":"web_adapters/#starlette-decorator","title":"Starlette (decorator)","text":"<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom rbacx.adapters.starlette import require_access\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": [\n    {\"id\": \"doc_read\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}}\n]}\nguard = Guard(policy)\n\ndef build_env(request: Request):\n    user_id = request.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user_id, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = Starlette()\n\n@app.route(\"/docs\")\n@require_access(guard, build_env, add_headers=True)\nasync def docs(request: Request):\n    return JSONResponse({\"ok\": True})\n</code></pre>"},{"location":"web_adapters/#flask-decorator","title":"Flask (decorator)","text":"<pre><code>from flask import Flask, jsonify\nfrom rbacx.adapters.flask import require_access\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": [\n    {\"id\": \"doc_read\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}}\n]}\nguard = Guard(policy)\n\ndef build_env(req):\n    user_id = req.headers.get(\"x-user\", \"anonymous\")\n    return Subject(id=user_id, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\napp = Flask(__name__)\n\n@app.route(\"/docs\")\n@require_access(guard, build_env, add_headers=True)\ndef docs():\n    return jsonify({\"ok\": True})\n</code></pre>"},{"location":"web_adapters/#django-rest-framework-permission-class","title":"Django REST Framework (permission class)","text":"<pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rbacx.adapters.drf import make_permission\nfrom rbacx import Guard\nfrom rbacx.core.model import Subject, Resource, Action, Context\n\npolicy = {\"algorithm\": \"deny-overrides\", \"rules\": [\n    {\"id\": \"doc_read\", \"effect\": \"permit\", \"actions\": [\"read\"], \"resource\": {\"type\": \"doc\"}}\n]}\nguard = Guard(policy)\n\ndef build_env(request):\n    user_id = getattr(request.user, \"username\", \"anonymous\")\n    return Subject(id=user_id, roles=[\"user\"]), Action(\"read\"), Resource(type=\"doc\"), Context()\n\nRBACXPermission = make_permission(guard, build_env)\n\nclass MyView(APIView):\n    permission_classes = [RBACXPermission]\n\n    def get(self, request, *args, **kwargs):\n        return Response({\"ok\": True})\n</code></pre>"},{"location":"why_choose/","title":"Why choose RBACX","text":""},{"location":"why_choose/#quick-comparison-at-a-glance","title":"Quick Comparison (at a glance)","text":"Criterion RBACX (Python) Casbin (Python) Oso (Polar + Python SDK) Django Guardian django-rules Flask-RBAC Policy definition JSON/YAML/Python dicts (declarative data + operators) Separate <code>model.conf</code> + policy storage (CSV/DB/etc.) Separate <code>.polar</code> files; declarative DSL No DSL; permissions stored in DB; backend checks No DSL; rules/predicates registered in Python In-code decorators/config registering role rules Framework integration Adapters for FastAPI, Flask, Django/DRF, Starlette/Litestar (middleware/deps/decorators) Library calls (<code>enforcer.enforce(...)</code>); framework glue typically user-built Enforce via <code>authorize()</code> in app code; ORM filtering helpers Django-only; integrates with <code>user.has_perm</code> and Django Admin Django-only backend; integrates with <code>has_perm</code> &amp; DRF helpers Flask-only; extension + decorators Query-time filtering Manual in app/repo layer Manual or custom helpers Helpers like <code>authorized_query</code> / <code>authorized_resources</code> for ORMs ORM patterns (filter by permissions) Manual (apply predicates or integrate with queryset logic) N/A (endpoint/role checks) Language scope Python Multi-language ecosystem Libraries for multiple languages Python/Django Python/Django Python/Flask"},{"location":"why_choose/#advantages-of-rbacx","title":"Advantages of RBACX","text":"<p>RBACX brings together role-based and attribute-based access control. You can start with simple role checks and add attribute-based conditions later\u2014without changing libraries or architecture. Many alternatives focus either on roles (e.g., Flask-RBAC, Casbin in its simplest use) or attributes (e.g., Oso, <code>rules</code>), whereas RBACX supports both approaches from the start.</p> <ul> <li> <p>Straightforward policy format   Policies are JSON/YAML (or Python dicts). Unlike Casbin (separate model + data) or Oso (a dedicated language), RBACX uses familiar configuration formats that non-programmers can review with care. The condition DSL is intentionally compact but sufficiently expressive for common business rules. For example: <pre><code>{\"==\": [ {\"attr\": \"resource.owner\"}, {\"attr\": \"subject.id\"} ]}\n</code></pre>   makes the \u201cowner\u201d check explicit. In Polar, the equivalent <code>resource.owner == user</code> is shorter but requires context on objects and language semantics. RBACX policies are easy to version and to send for security review.</p> </li> <li> <p>Clean, extensible codebase   RBACX is modular and easy to customize. If you want to store policies in PostgreSQL, implement a <code>PostgresPolicySource</code> and plug it into <code>Guard</code>\u2014no need to fork or patch the library. Casbin is also extensible but has a steeper API/model learning curve; Oso\u2019s engine is not designed for user-level engine extensions. RBACX is pure Python, so teams can audit, extend, or patch it directly. Code readability makes maintenance and debugging simpler.</p> </li> <li> <p>Adapters for multiple frameworks   Out of the box, RBACX provides adapters for FastAPI/Starlette, Flask, Django, and Litestar. This shortens integration time and enables the same authorization model across services built with different frameworks. In contrast, some alternatives are tied to one framework (Guardian \u2192 Django, Flask\u2011RBAC \u2192 Flask) or require custom glue code (Casbin, Oso).</p> </li> <li> <p>Hot policy reload   RBACX can watch file/HTTP/S3 sources and apply policy updates automatically using ETag checks. This suits dynamic environments where policies are frequently modified or centrally stored (e.g., S3). Guardian, <code>rules</code>, and Flask\u2011RBAC do not provide this out of the box; Casbin partially covers it (manual reload/watchers), while Oso library generally requires programmatic reloads.</p> </li> <li> <p>Explainability and obligations   RBACX decisions expose not only Permit/Deny but also why (e.g., <code>reason</code>, <code>rule_id</code>) and can include obligations (e.g., require MFA). Explainability aids debugging and audits. Competing libraries may not offer obligations in their open-source variants or return only a boolean decision.</p> </li> <li> <p>Lightweight with minimal dependencies   RBACX keeps the dependency footprint small (e.g., jsonschema for policy validation). A smaller footprint simplifies installation and reduces exposure to third\u2011party vulnerabilities.</p> </li> </ul>"},{"location":"why_choose/#verdict","title":"Verdict","text":"<p>RBACX delivers RBAC+ABAC with a declarative JSON policy model, secure defaults, combining algorithms, hot reload, explainable decisions, and ready-to-use adapters for major Python web frameworks. It\u2019s a pragmatic choice for teams that want fine-grained, auditable authorization without adopting a new policy language.</p> <p>Disclaimer: This page reflects the library author\u2019s perspective. For projects that require 100% reliability proven by years of production use, the choice may lean toward more mature and widely adopted solutions.</p>"}]}